<html>
 <head>
  <style type="text/css">
   div.hdr0 {color:black; font-weight: bold; font-size: 16pt; border-bottom:thick dotted #000000; font-family:Verdana, Arial}
   div.hdr1 {color:black; font-weight: bold; font-size: 14pt; border-bottom: 1px solid; font-family:Verdana, Arial }
   div.hdr2 {color:black; font-weight: bold; font-size: 12pt; font-family:Verdana, Arial }
   div.hdr3 {color:black; font-weight: bold; font-style:italic; xborder-bottom:dotted; font-family:Verdana, Arial; xwidth:500px }
   div.fnUndef {cfont-size: 9pt; color:orange; font-weight: bold; border-top-width:thin; border-left-width:thin; border-style:solid; }
   div.fnTba {font-size: 9pt; color:brown; font-weight: bold; border-top-width:thin; border-left-width:thin; border-style:solid; width: 100%; }
   div.fnUntested {font-size: 9pt; color:gray; font-weight: bold; border-style:solid; border-top-width:thin; border-left-width:thin;}
   div.fnFinal {font-size: 9pt; color:blue; font-weight: bold; border-left-width:thin; border-top-width:thin; border-style:solid;  xbackground-color:yellow; xborder-color: black }
   div.code {border-left-width:thin; xmargin-top:1em; border-style:solid; border:2px dotted black;background:#eee; padding-left:20px; padding-bottom:20px; padding-top:10px; }
   pre.pageBody {width : 540px; font-size:12px;}
  </style>
 </head>
 <body>
  <pre class=pageBody>
<div class=hdr0>About this document</div>

The purpose of this document is to give everyone, interrested in LGCK, something 
to work with when developing event scripts. 

<div class=hdr3>Function color</div>

Functions in blue have been tested and they're known to work.

Those marked in orange or red have either not been implemented, don't work or 
haven't been fully tested. Some of them are simply under consideration. 

Best usage of this document is to use the examples provided.

<div class=hdr3>Wrapper classes </div>

Wrapper classes provide nice encapsulation of LGCK object for use in a scripting 
context. However, modifying wrapper properties (such as x, y or aim) will not 
modify the corresponding LGCK objects. You have to use the provided methods for 
that, such as :moveTo or :moveBy.

<div class=hdr3>Conventions</div>

semi-colons as marker for methods

<div class=code>
Layer:getSize() 
</div>

dots as marker for properties.

<div class=code>
Sprite.x
Sprite.aim
</div>

all caps for constants

<div class=code>
UP
DOWN
LEFT
RIGHT
</div>

<div class=hdr3> Special notes</div>

The game engine recognizes many objects. These objects are numbered by their 
ObjectType (or ObjType) and can be referenced to by the OBJECT_XXXX constants. 
A type refers to an object not an instance.

An object instance (also called a sprite) is simply an occurence of the object 
found on a level.  ObjId (or ObjectId) refers to a specific instance of an 
object. Each of these occurences will have special properties such as a trigger 
key, visibility, frozen and goal attributs. In an object event handler, the 
objectId will always be available via the local variable `self`. (see examples)



<div class=hdr0>Event logic</div>

function event_obj_1_onSpawn (self,  ticks)
end

  IN: [[ int ]] self
      [[ int ]] ticks

  OUT:  na

  self  	objId which is handling the event
  ticks 	internal time counter (1 tick = 1/60 of second)

<div class=code>
 -- this a simple ai for a drone monster that moves LEFT/RIGHT. 

unMapSprite(self);

if canFall ( self) then
  moveSprite( self, DOWN)  ;
  playSound ("FALL");
else
  if ticks % 5 == 0 then
    local x;
    local y;
    local aim;

    x , y, aim = getSpriteVars(self)

    if isPlayerThere(self, aim) then
      attackPlayer ( self );
    end

    if aim < LEFT or aim > RIGHT then
      aim = LEFT
    end

    if canMove(self, aim) then
      moveSprite(self, aim);
      if canFall(self) then
	aim = 5 - aim;
	moveSprite(self, aim);
      end 
    else
	aim = XOR(aim, 1);      
    end

    setAim ( self, aim );

  end 
end

mapSprite(self);
</div>



<div class=hdr0>LGCK event model</div>

<div class=hdr1>level</div>

<div class=hdr2>onCreate</div>
This method is called when the level is first created.

<div class=hdr2>onDraw</div>
This method is called when it's time to draw the screen. 

<div class=hdr2>onRestart</div>
This method is  called when the level is restarted.

<div class=hdr2>onGoalCollected</div>
This method is called when all the goals are collected just before the level is 
completed

<div class=hdr2>onGoalKilled</div>
This method is called when a sprite marked as a goal is killed.

<div class=hdr2>onLevelCompleted</div>
This method is called just before moving to the next level.

<div class=hdr2>onTimeOut</div>
This method is called when timeLeft reaches zero.

<div class=hdr2>onKeyPressed</div>
This method is called when a key is presed. Use getLastKey() to retrieve the 
keyCode.

<div class=hdr2>onKeyUp</div>
This method is called when a key is released.  Use getLastKey() to retrieve the 
keyCode.


<div class=hdr1>sprite</div>

<div class=hdr2>onSpawn</div>
This method is called when this object is created ( respawns included ).

<div class=hdr2>onActivate</div>
This method is called when this object is activated.

<div class=hdr2>onDeath</div>
This method is called when this object is destroyed (death, picked up etc.)

<div class=hdr2>onHurt</div>
This method is called when this object is hurt. Only applies to player at the 
moment.

<div class=hdr2>onTouch</div>
This method is called when the player touches this object.

<div class=hdr2>onTrigger</div>
This method is  when a trigger is called on this object. Trigger key on this 
object must match that of the source for this event to be called.

<div class=hdr2>onHandler</div>
This method is called when the object handler is called. You can use this method 
to redefine the custom monster class for example.

<div class=hdr2>onSplat </div>
This method is called  when the player falls on this object.

<div class=hdr2>onHitTest</div>
This method is called when the player hit this object from below. (player aim 
supplied)

<div class=hdr2>onZKey</div>
This method is called z-key action performed on this object

<div class=hdr2>onAuto</div>
This method is executed when automated timer rings

<div class=hdr2>onLeftClick</div>
This method is called when the player left click on this sprite

<div class=hdr2> onRightClick</div>
This method is called when the player right click on this sprite

<div class=hdr2>onPowerUp ???</div>
tba

<div class=hdr2> onJump</div>
This method is called when the player jumps. 

<div class=hdr2>onFall</div>
This method is called then object falls. 

<div class=hdr2>onLanding</div>
This method is called when the object lands after a fall.

<div class=hdr2>onLeap</div>
This method is called when object performs as leap. Similar to onMove.

<div class=hdr2>onMove</div>
This method is called when the object is moving (e.g. walking). This is 
currently only implemented for the player.

<div class=hdr2>onFire</div>
This method is called  when the player/monster is firing.



<div class=hdr0>class Counters</div>


<div class=fnFinal>int Counters:get(string name) [lua]</div>

  IN:  [[ string name ]] 

  OUT: [[ int ]] 

<div class=hdr3>description:</div>

Get the value of given counter.



<div class=fnFinal>void Counters:set(string name, int value) [lua]</div>

  IN:  [[ string ]] name
       [[ int ]] value

  OUT: na

<div class=hdr3>description:</div>

Set the value of a given counter.



<div class=hdr0>class Debug</div>

<div class=hdr3>description</div>
This class provides wrapper for common debugging functions. It helps finding 
bugs by allowing direct manipulation of the debug console.

<div class=code>
Debug:printf("The result of 1 + 1 = %d", 1 + 1);
</div>



<div class=fnFinal>void Debug:clear() [lua]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

clear the debug console.

<div class=code>
Debug:clear();
</div>

THIS FUNCTION IS UNSTABLE.



<div class=fnFinal>void Debug:hide() [lua]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

hide the debug console.

example:

<div class=code>
Debug:hide();
</div>



<div class=fnFinal>string Debug:printf(string fmt, ...) [lua]</div>

  IN:  [[ string ]] fmt

  OUT: [[ string ]] 

<div class=hdr3>description:</div>

works just like the regular C printf excepts that all text strings go to the 
debug console.

<div class=code>
Debug:printf("1 + 1 = %d", 2);
</div>



<div class=fnFinal>void Debug:show() [lua]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

show the debug console.

<div class=code>
Debug:show();
</div>



<div class=hdr0>class Display</div>

<div class=hdr3>description</div>
Displays are overlays on top of the game screen. These can be scores, lives, 
points or other messages to be passed on to the player during the game.

default displays are

<div class=code>
timeLeft
score
debug
pause
</div>

These can be customized using lua scripting.

<div class=hdr3>members</div>
     int id The unique identifer of this display.

<div class=fnFinal>void Display:enableShadows(bool toggle) [lua]</div>

  IN:  [[ bool ]] toggle

  OUT: na

<div class=hdr3>description:</div>

Enable the shadow under this display. Only applies to text only. If `toggle` is 
set to true the shadows are displayed otherwise they're not. You can use other 
methods to redefine how the shadows are shown.

<div class=code>
local display = getDisplayByName("message");
display:enableShadows(true);
</div>



<div class=fnUntested>void Display:expire(int time) [lua]</div>

  IN:  [[ int ]] time

  OUT: na

<div class=hdr3>description:</div>

another alias from Display:setExpireTime()



<div class=fnFinal>void Display:hide() [lua]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

Hide this display.

example
<div class=code>
local display = getDisplayByName("timeLeft");
display:hide();
</div>



<div class=fnFinal>void Display:move(int x, int y) [lua]</div>

  IN:  [[ int ]] x
       [[ int ]] y

  OUT: na

<div class=hdr3>description:</div>

this is another alias from Display:setXY



<div class=fnFinal>void Display:remove() [lua]</div>

  IN:  na

  OUT: na




<div class=fnFinal>void Display:setAlpha(int alpha) [lua]</div>

  IN:  [[ int ]] alpha

  OUT: na




<div class=fnFinal>void Display:setColor(int r, int g, int b, int a) [lua]</div>

  IN:  [[ int ]] r
       [[ int ]] g
       [[ int b ]] 
       [[ int ]] a

  OUT: na

<div class=hdr3>description:</div>

This function changes the color of the text contained in the display.

<div class=code>
local score = getDisplayByName("score");
score:setColor(0xff, 0xff, 0xff, 0x80);
score:setFontSize(24);
</div>



<div class=fnFinal>void Display:setContent() [lua]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

same as setText



<div class=fnUntested>void Display:setExpireTime(int time) [lua]</div>

  IN:  [[ int ]] time

  OUT: na




<div class=fnFinal>void Display:setFontSize(int pxSize) [lua]</div>

  IN:  [[ int ]] pxSize

  OUT: na

<div class=hdr3>description:</div>

Change the font size of a given text display.

<div class=code>
local display = getDisplayByName("message");
display:setFontSize(20);
</div>



<div class=fnFinal>void Display:setShadowColor(int red, int green, int blue, int alpha) [lua]</div>

  IN:  [[ int ]] red
       [[ int ]] green
       [[ int ]] blue
       [[ int ]] alpha

  OUT: na

<div class=hdr3>description:</div>

set the color of the shadow under the text in the display. works for text-only 
display and ony if shadows have been enabled.

<div class=code>
display:setShadowColor(255, 32, 32, 255);
</div>



<div class=fnFinal>void Display:setShadowOffset(int tx, int ty) [lua]</div>

  IN:  [[ int ]] tx
       [[ int ]] ty

  OUT: na

<div class=hdr3>description:</div>

changes the relative position of the shadow under the text. works only in text-
only display and only if the shadow was enabled (see. enableShadow(...).

<div class=code>
display:setShadowOffset(1,1);
</div>



<div class=fnFinal>void Display:setSize(int pxSize) [lua]</div>

  IN:  [[ int ]] pxSize

  OUT: na

<div class=hdr3>description:</div>

This is an alias Display:setFontSize().

<div class=code>
display:setSize(40);
</div>



<div class=fnFinal>void Display:setText(string text) [lua]</div>

  IN:  [[ string ]] text

  OUT: na




<div class=fnUntested>void Display:setType(int displayType) [lua]</div>

  IN:  [[ int ]] displayType

  OUT: na




<div class=fnFinal>void Display:setXY(int x, int y) [lua]</div>

  IN:  [[ int ]] x
       [[ int ]] y

  OUT: na

<div class=hdr3>description:</div>

This is just an alias for :move.



<div class=fnFinal>void Display:show() [lua]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

Show this display.

example
<div class=code>
local display = getDisplayByName("timeLeft");
display:show();
</div>



<div class=fnFinal>int Display:sizeText([ string text ]) [lua]</div>

  IN:  [[ string ]] text*

  OUT: [[ int ]] size

<div class=hdr3>description:</div>

Returns the text size inside a display. The text is optional. If omitted, it 
will be taken from the display itself.



<div class=hdr0>class Element</div>

<div class=hdr3>description</div>
Elements are visual components on layers other than main. They can be 
manipulated by  programming through the Element class at runtime. Used in 
concert with Layer, this functionality provided a powerful way of controlling 
the paralax scrolling and other multi-layer game visual effects.



<div class=hdr3>members</div>
     int x 
     int y 
     bool show 
     int imageSet 
     int imageNo 
     int id 

<div class=fnUntested>void Element:hide() [lua]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

Hide this element.



<div class=fnUntested>bool Element:move(int aim) [lua]</div>

  IN:  [[ int ]] aim

  OUT: [[ bool ]] 

<div class=hdr3>description:</div>

Move this element to the direction of the given `aim`. This will change the 
position by eight pixel in one of following direction. These constants cannot 
be combined.

<div class=code>
UP
DOWN
LEFT
RIGHT
</div>



<div class=fnFinal>void Element:moveBy(int tx, int ty) [lua]</div>

  IN:  [[ int ]] tx
       [[ int ]] ty

  OUT: na

<div class=hdr3>description:</div>

Move the element by translation. The new position is the result of `x = x + tx` 
and `y = y + ty`. 

<div class=code>
local layer = getLayer( "fw");

for i=1, layer:getSize()  do

  local t = rand () % 8;

  local e = layer:getElement( i - 1);
  if (e.y > BUFFERHEI) then
    e:moveTo(rand() % BUFFERLEN, (rand() % BUFFERHEI) - BUFFERHEI);
  else
     if (t == 0) then
       e:moveBy(1, 0);
     end

     if (t == 7) then
        e:moveBy(-1, 0);
     end

     e:moveBy(0, 4);
  end

end
</div>



<div class=fnFinal>void Element:moveTo(int x, int y) [lua]</div>

  IN:  [[ int ]] x
       [[ int ]] y

  OUT: na

<div class=hdr3>description:</div>

Move this element to a new position.

<div class=code>
e:moveTo(100, 100)
</div>



<div class=fnUntested>void Element:setImage(int imageSet, int imageNo) [lua]</div>

  IN:  [[ int ]] imageSet
       [[ int ]] imageNo

  OUT: na

<div class=hdr3>description:</div>

Change the image assigned to a given element.



<div class=fnUntested>void Element:show() [lua]</div>

  IN:  na

  OUT: na




<div class=hdr0>class Extra</div>

<div class=hdr3>description</div>
Extra provides a wrap for the sprite runtime information which is used by the 
engine to manage it.

<div class=code>
local extra = getExtra(self);
</div>

<div class=hdr3>members</div>
     int objId 
     int orgProto 
     int orgX 
     int orgY 
     int hp 
     int oldAim1 
     int oldAim2 
     int fallHeight 
     int lives 
     int active 
     int bulletCount 
     int owner 
     int flags 
     int pathDir 
     int pathPtr 
     int animSeq 
     int animPtr 
     int animSpeed 
     int deathIndicator 





<div class=hdr0>class Global</div>


<div class=fnTba>int Global:getInt(string name) [lua]</div>

  IN:  [[ string ]] name

  OUT: [[ int ]] 




<div class=fnTba>string Global:getString(string value) [lua]</div>

  IN:  [[ string ]] value

  OUT: [[ string ]] 




<div class=fnTba>void Global:setInt(string name, int value) [lua]</div>

  IN:  [[ string ]] name
       [[ int ]] value

  OUT: na




<div class=fnTba>void Global:setString(string name, string value) [lua]</div>

  IN:  [[ string ]] name
       [[ string ]] value

  OUT: na




<div class=hdr0>class HitTest</div>

<div class=hdr3>description</div>
The HitTest class contains the results of the hit test performed by getHitTest().
 That information is a bit mangled so this class provides a wrapper to make it 
easier to work with.

bkCount is just a count of the number of entries in the bkClass array. The same 
information can be had using the pound operator (e.g. #bkClass). The same can 
be said for fwCount and acCount. 

fwEntry and acEntry are arrays of objIds. They represent sprites. 

If you wanted more information on any of them you could use the Sprite object 
wrapper.

<div class=code>
local ht = getHitTest(self, UP);
local sprite = getSprite ( ht.fwEntry [ i ]  );
</div>





<div class=hdr3>members</div>
     int bkCount 
     array bkClass 
     int fwCount 
     array fwClass 
     array fwEntry 
     int acCount 
     array acClass 
     array acEntry 
     int flags 
     bool player 





<div class=hdr0>class Inventory</div>

<div class=hdr3>description</div>
The Inventory is a subset of objects that the player can carry with him/her. 
Adding a new object to the inventory allows for specific interractions. (the 
term object refers to an object and not an instance, which is althogether 
different)




<div class=fnUndef>void Inventory:addItem(int objType) [lua]</div>

  IN:  [[ int ]] objType

  OUT: na




<div class=fnUndef>bool Inventory:hasItem(int objType) [lua]</div>

  IN:  [[ int ]] objType

  OUT: [[ bool ]] result




<div class=fnUndef>void Inventory:removeItem(int objType) [lua]</div>

  IN:  [[ int ]] objType

  OUT: na




<div class=fnUndef>void Inventory:reset() [lua]</div>

  IN:  na

  OUT: na




<div class=hdr0>class Layer</div>

<div class=hdr3>description</div>
Layer are broken into distinct group: background and foreground. The former are 
displayed behing the main layer, while the later are on top. The Layer allows 
for direct manipulation of all layers other than main. 

Objects on the main layer are sprites and are accessible through the Sprite 
interface.

<div class=hdr3>members</div>
     int id The unique identifier of this layer.
     string name 
     int type 

<div class=fnFinal>Element Layer:addElement(int ImageSet, int imageNo, int x, int y, [ bool show ])
 [lua]</div>

  IN:  [[ int ]] ImageSet
       [[ int ]] imageNo
       [[ int ]] x
       [[ int ]] y
       [[ bool ]] show*

  OUT: [[ Element ]] 

<div class=hdr3>description:</div>

Create a new Element on this layer. This function returns an Element object.

If show is omited, it is assumed to be false. This causes the element to be 
invisible by default.

<div class=code>
local layer = getLayer( "fw");

local element = layer:addElement(IMAGES_WHITEBALL_PNG, 0, 100, 100, true);

for i=1, 10 do
 local e = layer:addElement( IMAGES_WHITEBALL_PNG, 0, rand() % BUFFERLEN, (rand()
 % BUFFERHEI) - BUFFERHEI, true ) ;

end
</div>



<div class=fnFinal>void Layer:clear() [lua]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

Clear the layer.

<div class=code>
local layer = getLayer( "fw");
layer:clear();
</div>



<div class=fnUndef>void Layer:delete() [lua]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

Remove this layer. (this may invalidate the other layer id)



<div class=fnFinal>Element Layer:getElement(int index) [lua]</div>

  IN:  [[ int ]] index

  OUT: [[ Element ]] 

<div class=hdr3>description:</div>

returns an Element from this layer.



<div class=fnFinal>int Layer:getSize() [lua]</div>

  IN:  na

  OUT: [[ int ]] size

<div class=hdr3>description:</div>

return the element count for the given layer.

<div class=code>
local layer = getLayer( "fw");
Debug:printf("layer size: %d", layer:getSize());
</div>



<div class=fnUndef>void Layer:setSpeed(int hSpeed, int vSpeed) [n/a]</div>

  IN:  [[ int ]] hSpeed
       [[ int ]] vSpeed

  OUT: na

<div class=hdr3>description:</div>

Set the scroll speed of this layer.

Valid values include

<div class=code>
        SPEED_NOSCROLL,
        SPEED_WHOLE,
        SPEED_1_2,
        SPEED_1_4,
        SPEED_1_8,
        SPEED_1_16,
        SPEED_1_32
</div>



<div class=hdr0>class Proto</div>

<div class=hdr3>description</div>
Proto is the object property sheet. It represents the sum of all the information 
that is defined within the editor.

You can get an instance of Proto through the getProto() method of Sprite or the 
global getProto() functions. See relevant documentation for details.

<div class=hdr3>members</div>
     string name 
     int noSmartMap 
     int jumpMode 
     int maxFall 
     int imageSet 
     int imageNo 
     int moveSpeed 
     int aniSpeed 
     int defaultAim 
     int points 
     int buddy 
     int options 
     int chProto 
     int chSound 
     int fallSpeed 
     int damages 
     int bonusHP 
     int powerLevel 
     int rebirthDelay 
     int rebirths 
     int autoProto 
     int autoBullet 
     int autoSound 
     int autoTrigger 
     int hp 
     int autoProtoTime 
     int autoBulletTime 
     int autoSoundTime 
     int autoTriggerTime 
     int maxBullets 
     int fireRate 
     int extra1 
     int extra2 





<div class=hdr0>class Sprite</div>

<div class=hdr3>description</div>
The Sprite class is a lua wrapper for LGCK's Sprite object.

It allows direct manipulation of the engine data through the member functions.

Directly modifying member variables in a lua object doesn't modify the engine 
object however. Please use the appropriate member functions for that.

This is a how to get an instance of the Sprite class in an event handlers.
<div class=code>
local sprite = getSprite( self );
</div>

<div class=hdr3>members</div>
     int x 
     int y 
     int aim 
     int triggerFlag 
     int stateFlag 
     int actionMask 
     int imageSet 
     int imageNo 
     int objType 
     int id 
     string name 
     int class 

<div class=fnUntested>void Sprite:activate() [lua]</div>

  IN:  na

  OUT: na




<div class=fnFinal>void Sprite:attackPlayer() [lua]</div>

  IN:  na

  OUT: na




<div class=fnFinal>void Sprite:callEvent(int event) [lua]</div>

  IN:  [[ int ]] event

  OUT: na

<div class=hdr3>description:</div>

Call an event handler for this sprite. 

<div class=code>
local player = getPlayer();
player:callEvent( EO_DEATH );
</div>

For complete list of all available events see callObjEvent() for details.



<div class=fnFinal>bool Sprite:canFall() [lua]</div>

  IN:  na

  OUT: [[ bool ]] 

<div class=hdr3>description:</div>

This function returns true if the sprite can fall. 

<div class=code>
local s = getSprite( self );
local tmp = copySprite ( s );

local fall = 0;
while tmp:canFall() do
  tmp:move( DOWN );
  fall = fall + 1;
end

tmp:clear();

if fall < 20 then
  playSound("short fall.ogg");
else
  playSound("fall.ogg");
end

</div>



<div class=fnFinal>bool Sprite:canMove(int aim) [lua]</div>

  IN:  [[ int ]] aim

  OUT: [[ bool ]] 




<div class=fnFinal>void Sprite:changeTo(int objType) [lua]</div>

  IN:  [[ int ]] objType

  OUT: na




<div class=fnFinal>int Sprite:childCount() [lua]</div>

  IN:  na

  OUT: [[ int ]] count

<div class=hdr3>description:</div>

Count the number of children. Typically these are bullets.



<div class=fnFinal>void Sprite:clear() [lua]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

<div class=code>
local s = getSprite( self );
local tmp = copySprite ( s );
...
tmp:clear();
</div>



<div class=fnFinal>Sprite Sprite:copy() [lua]</div>

  IN:  na

  OUT: [[ Sprite ]] 

<div class=hdr3>description:</div>

Create a copy of this sprite.



<div class=fnUndef>int Sprite:frameCount() [lua]</div>

  IN:  na

  OUT: [[ int ]] 

<div class=hdr3>description:</div>

Returns the frame count for the Sprite's active frame set.



<div class=fnFinal>void Sprite:freeze() [lua]</div>

  IN:  na

  OUT: na




<div class=fnFinal>Extra Sprite:getExtra() [lua]</div>

  IN:  na

  OUT: [[ Extra ]] 




<div class=fnUndef>int Sprite:getHP() [lua]</div>

  IN:  na

  OUT: [[ int ]] hp

<div class=hdr3>description:</div>

get the sprite hit points



<div class=fnFinal>Proto Sprite:getProto() [lua]</div>

  IN:  na

  OUT: [[ Proto ]] 




<div class=fnUntested>string Sprite:getString() [lua]</div>

  IN:  na

  OUT: [[ string ]] 

<div class=hdr3>description:</div>

Get the hint/description associated with a given sprite



<div class=fnUntested>int Sprite:height() [lua]</div>

  IN:  na

  OUT: [[ int ]] height

<div class=hdr3>description:</div>

Get sprite height (pixels).



<div class=fnFinal>void Sprite:hide() [lua]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

Hide the sprite.
<div class=code>
local player = getPlayer();
player:hide();
if player:isHidden() then
   Debug:printf("%s is hidden", player.name);
end 
</div>



<div class=fnUntested>HitTest Sprite:hitTest(aim) [lua]</div>

  IN:  [[ aim ]] 

  OUT: [[ HitTest ]] 

<div class=hdr3>description:</div>

returns a hit test object.



<div class=fnUntested>bool Sprite:isActive() [lua]</div>

  IN:  na

  OUT: [[ bool ]] active

<div class=hdr3>description:</div>

Get the sprite active state. This is set through the activation policy.



<div class=fnFinal>void Sprite:isDead() [lua]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

returns true if the sprite is dead !

<div class=code>
local player = getPlayer();
killPlayer();
if player:isDead() then
   Debug:printf("player is dead");
end
</div>



<div class=fnUndef>bool Sprite:isFrozen()() [lua]</div>

  IN:  na

  OUT: [[ bool ]] 

<div class=hdr3>description:</div>

returns true if the sprite is frozen



<div class=fnUndef>bool Sprite:isGoal() [lua]</div>

  IN:  na

  OUT: [[ bool ]] 

<div class=hdr3>description:</div>

returns true is the sprite is marked as a goal.



<div class=fnFinal>void Sprite:isHidden() [lua]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

returns true if the sprite is hidden.

<div class=code>
local player = getPlayer();
Debug:printf("player id= %d; name: %s", player.id, player.name);
player:hide();
if player:isHidden() then
   Debug:printf("%s is hidden", player.name);
end 
</div>



<div class=fnUntested>bool Sprite:isMonster() [lua]</div>

  IN:  na

  OUT: [[ bool ]] 




<div class=fnUntested>bool Sprite:IsPlayer() [lua]</div>

  IN:  na

  OUT: [[ bool ]] 

<div class=hdr3>description:</div>

Tests if this sprite is a player object.



<div class=fnFinal>bool Sprite:isPlayerThere(int aim) [lua]</div>

  IN:  [[ int ]] aim

  OUT: [[ bool ]] 




<div class=fnFinal>bool Sprite:isVisible() [lua]</div>

  IN:  na

  OUT: [[ bool ]] 




<div class=fnFinal>void Sprite:kill() [lua]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

Kills the sprite. Don't try this inside the sprite's own event handler!!!

<div class=code>
local player = getPlayer();
player:kill();
if player:isDead() then
   Debug:printf("`%s` is dead", player.name);
end 
</div>



<div class=fnUndef>void Sprite:land() [lua]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

Calls the default "landing" code for this sprite. This is typically used when an 
sprite has stopped from a free fall. land() checks if the sprite's maxFall 
property is exceeded and kills the sprite as appropriate.



<div class=fnFinal>void Sprite:map() [lua]</div>

  IN:  na

  OUT: na




<div class=fnUndef>void Sprite:markAsGoal() [lua]</div>

  IN:  na

  OUT: na




<div class=fnFinal>void Sprite:move(int aim) [lua]</div>

  IN:  [[ int ]] aim

  OUT: na

<div class=hdr3>description:</div>

Move the sprite in a given direction; UP, DOWN, LEFT or RIGHT



<div class=fnFinal>void Sprite:moveBy(int tx, int ty) [lua]</div>

  IN:  [[ int ]] tx
       [[ int ]] ty

  OUT: na




<div class=fnFinal>void Sprite:moveTo(int x, int y) [lua]</div>

  IN:  [[ int ]] x
       [[ int ]] y

  OUT: na




<div class=fnFinal>int Sprite:objClass() [lua]</div>

  IN:  na

  OUT: [[ int ]] classId




<div class=fnFinal>string Sprite:objName() [lua]</div>

  IN:  na

  OUT: [[ string ]] name of the object




<div class=fnFinal>int Sprite:objType() [lua]</div>

  IN:  na

  OUT: [[ int ]] TypeId




<div class=fnFinal>Proto Sprite:proto() [lua]</div>

  IN:  na

  OUT: [[ Proto ]] 

<div class=hdr3>description:</div>

same as getProto()



<div class=fnFinal>void Sprite:setAim(int aim) [lua]</div>

  IN:  [[ int ]] aim

  OUT: na


<div class=hdr3>paramIns:</div>

   aim             UP, DOWN, LEFT, RIGHT





<div class=fnUntested>void Sprite:setAsGoal() [lua]</div>

  IN:  na

  OUT: na




<div class=fnUntested>void Sprite:setHP(int hp) [lua]</div>

  IN:  [[ int ]] hp

  OUT: na

<div class=hdr3>description:</div>

set the sprite hit points



<div class=fnFinal>void Sprite:setImage([ int imageSet ], int imageNo) [lua]</div>

  IN:  [[ int ]] imageSet*
       [[ int ]] imageNo

  OUT: na

<div class=hdr3>description:</div>

Change the image of the given sprite. 

<div class=code>
local sprite = getSprite(self);
sprite:setImage(sprite.imageSet, XOR(sprite.imageNo,1));
</div>



<div class=fnUndef>Sprite Sprite:setOwner() [lua]</div>

  IN:  na

  OUT: [[ Sprite ]] owner

<div class=hdr3>description:</div>

Set the owner of this sprite



<div class=fnFinal>int Sprite:setState(int stateFlag, [ bool flip ]) [lua]</div>

  IN:  [[ int ]] stateFlag
       [[ bool ]] flip*

  OUT: [[ int ]] stateFlag

<div class=hdr3>description:</div>

Change the state flags for this sprite.

if flip is true the bits are set on otherwise they are cleared. Flip is optional 
and assumed to be true.

State flag is a combination of the following:

<div class=code>
    STATE_FALL		
    STATE_DEAD	
    STATE_HIT		    
    STATE_JUMP	
    STATE_BEGINNING    
    STATE_FIRING       
    STATE_LOOKUP       
</div>

Example usage:

<div class=code>
local player = getPlayer();
player:setState(STATE_DEAD);
</div>

returns the newly modified state flag.



<div class=fnFinal>void Sprite:setTriggerKey(int key) [lua]</div>

  IN:  [[ int ]] key

  OUT: na




<div class=fnFinal>void Sprite:show() [lua]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

Show this sprite. This reverses the effect of Sprite:hide().

<div class=code>
local player = getPlayer();
if player:isHidden() then
   Debug:printf("%s is hidden", player.name);
end 
player:show();
</div>



<div class=fnUndef>void Sprite:spawn() [lua]</div>

  IN:  na

  OUT: na




<div class=fnFinal>void Sprite:stopAnimation() [lua]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

Stop the sprite's animation sequence. see stopAnimation() for details.

<div class=code>
local sprite = getSprite( self );
sprite:stopAnimation();
</div>



<div class=fnFinal>bool Sprite:testFlags(int mask) [lua]</div>

  IN:  [[ int ]] mask

  OUT: [[ bool ]] result




<div class=fnFinal>void Sprite:triggerHitState() [lua]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

Trigger the hit state for this sprite. See triggerHitState() for details.

<div class=code>
local player = getPlayer();
player:triggerHitState();
</div>



<div class=fnFinal>bool Sprite:tryAnimation(int animSeq) [lua]</div>

  IN:  [[ int ]] animSeq

  OUT: [[ bool ]] 

<div class=hdr3>description:</div>

see tryAnimation() for details



<div class=fnFinal>bool Sprite:tryPath(int path, [ int aim ]) [lua]</div>

  IN:  [[ int ]] path
       [[ int ]] aim*

  OUT: [[ bool ]] 

<div class=hdr3>description:</div>

Apply a defined path to a sprite. Path can be any PS_XXXX constants. See tryPath(
) for details.

<div class=code>
local player = getPlayer();
player:tryPath(PS_JUMP_LEFT);
</div>



<div class=fnUndef>void Sprite:unFreeze() [lua]</div>

  IN:  na

  OUT: na




<div class=fnFinal>void Sprite:unMap() [lua]</div>

  IN:  na

  OUT: na




<div class=fnUndef>void Sprite:unmarkAsGoal() [n/a]</div>

  IN:  na

  OUT: na




<div class=fnUndef>void Sprite:unsetAsGoal() [n/a]</div>

  IN:  na

  OUT: na




<div class=fnUntested>int Sprite:width() [lua]</div>

  IN:  na

  OUT: [[ int ]] width

<div class=hdr3>description:</div>

Get sprite width in pixels.



<div class=hdr0>functions</div>

<div class=fnUntested>void activateSprite(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: na




<div class=fnFinal>Display addDisplay(string name, int x, int y, int type) [lua]</div>

  IN:  [[ string ]] name
       [[ int ]] x
       [[ int ]] y
       [[ int ]] type

  OUT: [[ Display ]] 

<div class=hdr3>description:</div>

similar to addDisplayC excepts that it returns a Display obj

after adding a new Display object also remember to set it visible using the 
Display:setVisible method.

<div class=code>
    DISPLAY_TIME_LEFT   
    displays the timeLeft counter
    
    DISPLAY_MESSAGE
    displays a text message
     
    DISPLAY_SCORE       
    displays the user' score

    DISPLAY_LIVES      
    display available lives
    
    DISPLAY_HP         
    display the hp counter 

    DISPLAY_DEBUG	
    displays the debug console
</div>

when a game is run there are already several displays defined. you may modify 
these displays using getDisplay() with the appropriate name string.

example

<div class=code>
local displayId;

displayId = findDisplay("timeLeft");
debug("timeLeft id: " .. displayId);

displayId = findDisplay("score");
debug("score id: " .. displayId);

local timeLeft = getDisplayByName("timeLeft");
timeLeft:setColor(0xff, 0xff, 0, 0x80);
timeLeft:move(SCREENLEN - 100, 0);
timeLeft:setFontSize(50);

local score = getDisplayByName("score");
score:setColor(0xff, 0xff, 0xff, 0x80);
score:setFontSize(24);

local t = addDisplay("test", 64, 64, DISPLAY_MESSAGE);
t:setText("this is a test\nSonia and the Pumpkins");
t:show();
</div>



<div class=fnFinal>int addDisplayC(string name, int x, int y, int type) [cpp]</div>

  IN:  [[ string ]] name
       [[ int ]] x
       [[ int ]] y
       [[ int ]] type

  OUT: [[ int ]] 


<div class=hdr3>paramOuts:</div>

   int             display uid or -1 if the function failed


<div class=hdr3>description:</div>

create a new display elements using ``name``, x, y, and type. 

you can use any of the DISPLAY_XXXX constants for ``type``.

<div class=code>
  DISPLAY_TIME_LEFT 
  DISPLAY_MESSAGE   
  DISPLAY_SCORE     
  DISPLAY_LIVES     
  DISPLAY_HP        
</div>

after adding a new display also remember to set it visible
using the displaySetVisible function.


<div class=code>
-- create a display of an image 
-- using the frame set 'ANNIE.OBL'
-- 0 is first image

local id = addDisplayC( "petImage", 60, 60, DISPLAY_IMAGE);
displaySetImage ( id, IMAGES_ANNIE_OBL  , 0 );
displaySetVisible ( id, true );
</div>

see addDisplay for more sample usages.



<div class=fnFinal>int addElement(int layerId, int imageSet, int imageNo, int x, int y, [ bool 
show ]) [cpp]</div>

  IN:  [[ int ]] layerId
       [[ int ]] imageSet
       [[ int ]] imageNo
       [[ int ]] x
       [[ int ]] y
       [[ bool ]] show*

  OUT: [[ int ]] elementId

<div class=hdr3>description:</div>

This function is used to add an element to a background or foreground layer. If 
you want to add a sprite to the main the layer use the appropriate sprite 
function.



<div class=fnUntested>Layer addLayer(string name, int type, [ int hSpeed ], [ int vSpeed ]) [lua]</div>

  IN:  [[ string ]] name
       [[ int ]] type
       [[ int ]] hSpeed*
       [[ int ]] vSpeed*

  OUT: [[ Layer ]] 

<div class=hdr3>description:</div>

see addLayerC



<div class=fnUntested>int addLayerC(String name, int type, [ int hSpeed ], [ int vSpeed ]) [cpp]</div>

  IN:  [[ String ]] name
       [[ int ]] type
       [[ int ]] hSpeed*
       [[ int ]] vSpeed*

  OUT: [[ int ]] layerId

<div class=hdr3>description:</div>

valid types

<div class=code>
    LAYER_BK             
    LAYER_FW            
</div>

valid speeds

<div class=code>
        SPEED_NOSCROLL,
        SPEED_WHOLE,
        SPEED_1_2,
        SPEED_1_4,
        SPEED_1_8,
        SPEED_1_16,
        SPEED_1_32
</div>



<div class=fnFinal>Sprite addSprite(int x, int y, int imageSet, int imageNo, int aim, int 
objectType, [ int imageSet ], [ int imageNo ]) [lua]</div>

  IN:  [[ int ]] x
       [[ int ]] y
       [[ int ]] imageSet
       [[ int ]] imageNo
       [[ int ]] aim
       [[ int ]] objectType
       [[ int ]] imageSet*
       [[ int ]] imageNo*

  OUT: [[ Sprite ]] 


<div class=hdr3>paramIns:</div>

   x               
   y               
   imageSet        
   imageNo         
   aim             either UP, DOWN, LEFT, RIGHT
   objectType      
   imageSet        
   imageNo         


<div class=hdr3>description:</div>

note:  modifying variables inside of sprite doesn't change the object on screen 
only your own local copy. to alter the sprite, use the build-in methods. see 
getSprite for more details



<div class=fnFinal>int addSpriteC(int x, int y, int aim, int objectType, [ int imageSet ], [ int 
imageNo ]) [cpp]</div>

  IN:  [[ int ]] x
       [[ int ]] y
       [[ int ]] aim
       [[ int ]] objectType
       [[ int ]] imageSet*
       [[ int ]] imageNo*

  OUT: [[ int ]] objId

<div class=hdr3>description:</div>

although it might not make any real difference but performance wise addSpriteC 
is probably faster that addSprite (if you don't need the extra overhead).



<div class=fnFinal>int addToHP(int hitPoints) [cpp]</div>

  IN:  [[ int ]] hitPoints

  OUT: [[ int ]] 


<div class=hdr3>paramOuts:</div>

   int             the player's new hp count


<div class=hdr3>description:</div>

negative values will be substracted. if the modication causes the player to fall 
under 0 hp. the player dies. therefor onDeath will also be called

addToHP will check for over bound value. if the player goes over maxHP, the 
value will be adjusted automatically

this function will also update the hp counter on screen



<div class=fnFinal>void addToInventory(int objectType) [cpp]</div>

  IN:  [[ int ]] objectType

  OUT: na

<div class=hdr3>description:</div>

Add an object to the inventory of the player.



<div class=fnFinal>int addToScore(int points) [cpp]</div>

  IN:  [[ int ]] points

  OUT: [[ int ]] current score

<div class=hdr3>description:</div>

add points to the player's score. this the function to use if you want to bypass 
the autogenerated point that fly to the top of the screen.

also note that if the value is negative, it will get deducted from the total no 
test is performed to check for negative scores or overflow



<div class=fnFinal>void alert(string text) [cpp]</div>

  IN:  [[ string ]] text

  OUT: na

<div class=hdr3>description:</div>

Create a standard message box with an okay button to display the text. Works 
just like the alert() function in javascript.

<div class=code>
alert("welcome home");
</div>



<div class=fnFinal>int AND(int a, int b) [cpp]</div>

  IN:  [[ int ]] a
       [[ int ]] b

  OUT: [[ int ]] 


<div class=hdr3>paramOuts:</div>

   int             binary AND (a , b)





<div class=fnFinal>void attackPlayer(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: na


<div class=hdr3>paramIns:</div>

   objId           obj id of the sprite who is attacking





<div class=fnUndef>void callGameEvent(int eventId) [cpp]</div>

  IN:  [[ int ]] eventId

  OUT: na

<div class=hdr3>description:</div>

<div class=code>
    EG_INIT_GAME        = 0;
    EG_PREPARE_LEVEL    = 1;
    EG_COMPLETE_LEVEL   = 2;
    EG_DEATH            = 3;
    EG_GOAL_COLLECTED   = 4;
    EG_GOAL_KILLED      = 5;
</div>



<div class=fnFinal>void callLvEvent(int event) [cpp]</div>

  IN:  [[ int ]] event

  OUT: na

<div class=hdr3>description:</div>

Call a level event. Valid values are the following.

<div class=code>
    EL_CREATE
    EL_DRAW 
    EL_RESTART
    EL_GOAL_COLLECTED
    EL_LEVEL_COMPLETED
    EL_TIMEOUT 		
    EL_KEY_PRESSED
    EL_KEY_UP 	
    EL_GOAL_KILLED   
    EL_HANDLER   
</div>



<div class=fnFinal>void callObjEvent(int objId, int event) [cpp]</div>

  IN:  [[ int ]] objId
       [[ int ]] event

  OUT: na

<div class=hdr3>description:</div>

Call an event handler. ObjId is the sprite to receive the event as you can see 
in the example below.

<div class=code>
local id = getPlayerC();
Debug:printf("player_id: %x", id);
callObjEvent(id, EO_DEATH);
</div>

Event can be any of the following constants.

<div class=code>
    EO_SPAWN   
    EO_ACTIVATE
    EO_DEATH	
    EO_HURT	    
    EO_TOUCH	
    EO_TRIGGER
    EO_HANDLER
    EO_SPLAT	
    EO_HIT_TEST
    EO_ZKEY	
    EO_AUTO	
    EO_JUMP
    EO_FALL	
    EO_LAND	
    EO_LEAP	
    EO_MOVE	
    EO_FIRE	
</div>



<div class=fnFinal>void callTrigger(int key) [cpp]</div>

  IN:  [[ int ]] key

  OUT: na


<div class=hdr3>paramIns:</div>

   key             number of this trigger (1-31)





<div class=fnFinal>bool canFall(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: [[ bool ]] 

<div class=hdr3>description:</div>

return true if the object identified by objId can fall. This is reflected by the 
current rules on the level.

<div class=code>
if (canFall ( self )) then
  debug ("I'm falling !!!");
end
</div>



<div class=fnFinal>bool canMove(int objId, int aim) [cpp]</div>

  IN:  [[ int ]] objId
       [[ int ]] aim

  OUT: [[ bool ]] 




<div class=fnFinal>void changeTo(int objId, int objType) [cpp]</div>

  IN:  [[ int ]] objId
       [[ int ]] objType

  OUT: na

<div class=hdr3>description:</div>

Change the sprite to another object based on objType.



<div class=fnFinal>void clearDisplay() [cpp]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

Remove all the visual displays on screen. This includes the score, timeLeft, 
health and debug, etc.

<div class=code>
clearDisplay();
</div>



<div class=fnUntested>void clearKeys() [cpp]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

Clear the states for all the keys.



<div class=fnFinal>void clearSprite(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: na

<div class=hdr3>description:</div>

Clear a sprite and mark the entry for garbage collection.



<div class=fnFinal>Sprite copySprite(Sprite src) [lua]</div>

  IN:  [[ Sprite ]] src

  OUT: [[ Sprite ]] newSprite

<div class=hdr3>description:</div>

Take the source sprite and create a new copy. Return an instance of the Sprite 
wrapper object.

CAUTION: using this function inside an handler such as OnSpawn can cause an 
infinite loop which will crash the engine.



<div class=fnFinal>int copySpriteC(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: [[ int ]] newObjId


<div class=hdr3>paramOuts:</div>

   int             the objId of the new object that was created.


<div class=hdr3>description:</div>

copy a sprite and create a new instance. This function returns the ObjId handle 
if succesful or -1 on failure.

CAUTION: using this function inside an handler such as OnSpawn can cause an 
infinite loop which will crash the engine.



<div class=fnFinal>int counters_get(string name) [cpp]</div>

  IN:  [[ string name ]] 

  OUT: [[ int ]] 

<div class=hdr3>description:</div>

Return the value of a counter.



<div class=fnFinal>void counters_set(string name, int value) [cpp]</div>

  IN:  [[ string ]] name
       [[ int ]] value

  OUT: na

<div class=hdr3>description:</div>

Set the value of a counter



<div class=fnFinal>int countGoals() [cpp]</div>

  IN:  na

  OUT: [[ int ]] 


<div class=hdr3>paramOuts:</div>

   int             number of object marked as goals. This is the same code as 
the one called by       engine's own isLevelCompleted().


<div class=hdr3>description:</div>

<div class=code>
debug("++goals: " .. countGoals());
</div>



<div class=fnFinal>void debug(string) [cpp]</div>

  IN:  [[ string ]] 

  OUT: na

<div class=hdr3>description:</div>

send a text string to the debug console.



<div class=fnFinal>void debugClear() [cpp]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

clear the debug log



<div class=fnUndef>void decTimeLeft() [n/a]</div>

  IN:  na

  OUT: na




<div class=fnFinal>int display_sizeText(int displayId, [ string text ]) [cpp]</div>

  IN:  [[ int ]] displayId
       [[ string ]] text*

  OUT: [[ int ]] size

<div class=hdr3>description:</div>

Returns the size of the string if not empty otherwise return the size of the 
text contained in the display.



<div class=fnFinal>void displayEnableShadows(int displayId, bool shadow) [cpp]</div>

  IN:  [[ int ]] displayId
       [[ bool ]] shadow

  OUT: na

<div class=hdr3>description:</div>

enable shadows under a display. work with text-only displays.

example

<div class=code>
local id = addDisplayC("goalCount", 258, 0, DISPLAY_MESSAGE);
displaySetText(id, "XX");
displaySetVisible ( id, true );
displayEnableShadows( id, true );
</div>



<div class=fnFinal>void displaySetAlpha(int displayId, int alpha) [cpp]</div>

  IN:  [[ int ]] displayId
       [[ int ]] alpha

  OUT: na




<div class=fnFinal>void displaySetColor(int displayId, int red, int green, int blue, int alpha) [
cpp]</div>

  IN:  [[ int ]] displayId
       [[ int ]] red
       [[ int ]] green
       [[ int ]] blue
       [[ int ]] alpha

  OUT: na




<div class=fnTba>void displaySetExpireTime(int displayId, int time) [cpp]</div>

  IN:  [[ int ]] displayId
       [[ int ]] time

  OUT: na




<div class=fnFinal>void displaySetFontSize(int displayId, int pxSize) [cpp]</div>

  IN:  [[ int ]] displayId
       [[ int ]] pxSize

  OUT: na

<div class=hdr3>description:</div>

Change the pixel size of the text inside a display. This applies to text display 
only. See example below.

<div class=code>
local id = addDisplayC("goalCount", 258, 0, DISPLAY_MESSAGE);
displaySetText(id, "XX");
displaySetVisible ( id, true );
displayEnableShadows( id, true );
displaySetShadowOffset(id, 2, 2);
displaySetFontSize(id, 14);
</div>



<div class=fnFinal>void displaySetImage(int displayId, int imageSet, int imageNo) [cpp]</div>

  IN:  [[ int ]] displayId
       [[ int ]] imageSet
       [[ int ]] imageNo

  OUT: [[ void ]] 

<div class=hdr3>description:</div>

Assign an image to a display designated by displayId.

imageSet is set from the gameDB. Use the IMAGES_XXXX constants.
imageNo are zero based index (from the first image, #0). 

Note that each display can only accomodate one thing. If you assign an image to 
display that originally contained text. That text will be gone.



<div class=fnFinal>void displaySetShadowColor(int displayId, int red, int green, int blue, int 
alpha) [cpp]</div>

  IN:  [[ int ]] displayId
       [[ int ]] red
       [[ int ]] green
       [[ int ]] blue
       [[ int ]] alpha

  OUT: na

<div class=hdr3>description:</div>

changes the color of the shadow cast by a display. works only with text displays 
where the shadow is enabled.

<div class=code>
local id = addDisplayC("lives", 188, 0, DISPLAY_LIVES);
displaySetVisible ( id, true );
displayEnableShadows( id, true );
displaySetShadowOffset(id, 2,2);
displaySetShadowColor(id, 200, 200, 240, 128);
</div>



<div class=fnFinal>void displaySetShadowOffset(int displayId, int tx, int ty) [cpp]</div>

  IN:  [[ int ]] displayId
       [[ int ]] tx
       [[ int ]] ty

  OUT: na

<div class=hdr3>description:</div>

change the offset of the shadow from the text. this works soley for text-only 
displays.

<div class=code>
local id = addDisplayC("lives", 188, 0, DISPLAY_LIVES);
displaySetVisible ( id, true );
displayEnableShadows( id, true );
displaySetShadowOffset(id, 2,2);
</div>



<div class=fnFinal>void displaySetText(int displayId, string text) [cpp]</div>

  IN:  [[ int ]] displayId
       [[ string ]] text

  OUT: na

<div class=hdr3>description:</div>

change the text displayed inside a text display.

example
<div class=code>
local id = findDisplay("goalCount");
-- local goals = sprintf( "%.2d", countGoals() );
local goals = sprintf("%.2d", getGoalLeft());
displaySetText( id, goals ) ;
</div>



<div class=fnUntested>void displaySetType(int displayId, int type) [cpp]</div>

  IN:  [[ int ]] displayId
       [[ int ]] type

  OUT: na




<div class=fnFinal>void displaySetVisible(int displayId, bool visible) [cpp]</div>

  IN:  [[ int ]] displayId
       [[ bool ]] visible

  OUT: na




<div class=fnFinal>void displaySetXY(int displayId, int x, int y) [cpp]</div>

  IN:  [[ int ]] displayId
       [[ int ]] x
       [[ int ]] y

  OUT: na

<div class=hdr3>description:</div>

change the position of a given display. x and y are absolute position given in 
pixels.

example

<div class=code>
local id = addDisplayC( "playerIcon", 60, 60, DISPLAY_IMAGE);
displaySetXY(id, 0, 128);
displaySetImage ( id, OBJECT_PLAYERS   ,  4 );
displaySetVisible ( id, true );
</div>



<div class=fnUntested>bool element_move(int layerId, int elementId, int aim) [cpp]</div>

  IN:  [[ int ]] layerId
       [[ int ]] elementId
       [[ int ]] aim

  OUT: [[ bool ]] 

<div class=hdr3>description:</div>

This function moves this element to a given aim. Valid values for aim are the 
following

<div class=code>
UP
DOWN
LEFT
RIGHT
</div>

return true if succesful



<div class=fnFinal>bool element_moveBy(int layerId, int elementId, int tx, int ty) [cpp]</div>

  IN:  [[ int ]] layerId
       [[ int ]] elementId
       [[ int ]] tx
       [[ int ]] ty

  OUT: [[ bool ]] 




<div class=fnFinal>bool element_moveTo(int layerId, int elementId, int x, int y) [cpp]</div>

  IN:  [[ int ]] layerId
       [[ int ]] elementId
       [[ int ]] x
       [[ int ]] y

  OUT: [[ bool ]] 




<div class=fnUntested>bool element_setImage(int layerId, int elementId, int imageSet, int imageNo) [
cpp]</div>

  IN:  [[ int ]] layerId
       [[ int ]] elementId
       [[ int ]] imageSet
       [[ int ]] imageNo

  OUT: [[ bool ]] 

<div class=hdr3>description:</div>

Change the image associated with a layer element.



<div class=fnUntested>void element_setVisible(int layerId, int elementId, bool show) [cpp]</div>

  IN:  [[ int ]] layerId
       [[ int ]] elementId
       [[ bool ]] show

  OUT: na

<div class=hdr3>description:</div>

Set a given element to hidden or shown. If show is true the object is set to 
visible otherwise, it is hidden.



<div class=fnFinal>int findDisplay(string name) [cpp]</div>

  IN:  [[ string ]] name

  OUT: [[ int ]] displayId


<div class=hdr3>paramOuts:</div>

   int             displayId or -1 if it doesn't exists


<div class=hdr3>description:</div>

findDisplay returns a displayId for an existing display.

These can be system display or an a user defined one. (see example)

example:

<div class=code>
-- find a previously created display
-- and update it

local id = findDisplay("goalCount");
local goals = sprintf( "%.2d", countGoals() );
displaySetText( id, goals ) ;
</div>



<div class=fnFinal>int findSprite(int class, [ int origin ]) [cpp]</div>

  IN:  [[ int ]] class
       [[ int ]] origin*

  OUT: [[ int ]] objId

<div class=hdr3>description:</div>

Find the first sprite from origin which match the given class. Origin can be 
omitted, in which, it is assumed to be index 0.

Returns the objId if a match is found or otherwise -1.

<div class=code>
local id = findSprte( CLASS_PLAYER_OBJECT );
</div>



<div class=fnUndef>int frameSet_getSize(int frameSet) [cpp]</div>

  IN:  [[ int ]] frameSet

  OUT: [[ int ]] size

<div class=hdr3>description:</div>

Get the number of images inside a frameset.



<div class=fnFinal>void freezeSprite(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: na

<div class=hdr3>description:</div>

Set the freeze flag to on. This will cause the sprite to stop moving. Engine 
class and animation handlers will honor this flag.

It is your responsability to support this flag in custom handlers of your own 
making.



<div class=fnFinal>mixed getBkColor() [lua]</div>

  IN:  na

  OUT: [[ int ]] red
       [[ int ]] green
       [[ int ]] blue

<div class=hdr3>description:</div>

returns three integer values for each individual components such as red, green 
and blue of the current level's background color. This is just an alias for 
getBkColorC()

<div class=code>
local bkColor = getBkColor();
Debug:printf("red: %u; green: %u; blue: %u", bkColor.red, bkColor.green, bkColor.
blue);
</div>



<div class=fnFinal>mixed getBkColorC() [cpp]</div>

  IN:  na

  OUT: [[ int ]] red
       [[ int ]] green
       [[ int ]] blue

<div class=hdr3>description:</div>

Get the background color for the current level. Return the color as individual 
components as shown in the out list.

<div class=code>
local red;
local green;
local blue;
red, green, blue = getBkColorC();

Debug:printf("red: %u; green: %u; blue: %u", red, green, blue);
</div>



<div class=fnUndef>int getClosureEvent() [cpp]</div>

  IN:  na

  OUT: [[ int ]] 




<div class=fnUndef>int getClosureTime() [cpp]</div>

  IN:  na

  OUT: [[ int ]] 




<div class=fnFinal>Display getDisplayById(int displayId) [lua]</div>

  IN:  [[ int ]] displayId

  OUT: [[ Display ]] 




<div class=fnFinal>Display getDisplayByName(string displayName) [lua]</div>

  IN:  [[ string ]] displayName

  OUT: [[ Display ]] 

<div class=hdr3>description:</div>

Create a lua Display object matching the engine display of the provided name.



<div class=fnFinal>Extra getExtra(int objId) [lua]</div>

  IN:  [[ int ]] objId

  OUT: [[ Extra ]] 

<div class=hdr3>description:</div>

see getExtraC()



<div class=fnFinal>array getExtraC(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: [[ array ]] 

<div class=hdr3>description:</div>

Returns an array containing the sprite's extra data.

You can access this information via the following indexes.

<div class=code>
    EXTRA_ORGPROTO
    EXTRA_ORGX
    EXTRA_ORGY
    EXTRA_HP
    EXTRA_OLDAIM1
    EXTRA_OLDAIM2
    EXTRA_FALLHEIGHT
    EXTRA_LIVES
    EXTRA_ACTIVE
    EXTRA_BULLETCOUNT
    EXTRA_OWNER
    EXTRA_FLAGS
    EXTRA_PATHDIR
    EXTRA_PATHPTR
    EXTRA_ANIMSEQ
    EXTRA_ANIMPTR
    EXTRA_ANIMSPEED
    EXTRA_DEATHINDICATOR
</div>



<div class=fnFinal>int getExtraUID(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: [[ int ]] uid

<div class=hdr3>description:</div>

Returns extraData uid for a given sprite.



<div class=fnFinal>int getGoalLeft() [cpp]</div>

  IN:  na

  OUT: [[ int ]] goalLeft

<div class=hdr3>description:</div>

Return the number of items marked as a goals on the left. This uses a 
precompiled value. In contrast, countGoals() will do make a new count.

example:

<div class=code>
local id = findDisplay("goalCount");
-- countGoals requires more computation
-- local goals = sprintf( "%.2d", countGoals() );
local goals = sprintf("%.2d", getGoalLeft());
displaySetText( id, goals ) ;
</div>



<div class=fnFinal>HitTest getHitTest(int objId, int aim) [lua]</div>

  IN:  [[ int ]] objId
       [[ int ]] aim

  OUT: [[ HitTest ]] 

<div class=hdr3>description:</div>

Takes an objId and returns a HitTest object.

see getHitTestC() for detais and HitTest class for details.



<div class=fnFinal>mixed getHitTestC(int objId, int aim) [cpp]</div>

  IN:  [[ int ]] objId
       [[ int ]] aim

  OUT: [[ array ]] bk
       [[ array ]] fw
       [[ array ]] ac
       [[ int ]] flags
       [[ bool ]] player

<div class=hdr3>description:</div>

Performs a hit test for a given object (sprite) and return the result. This raw 
data straight from the game engine. Of course if you are looking at this 
function it's because you are into writing ai and advances engine extension so 
you ought to expect a bit of complexity.

The objId is generally the "self" variable you would get from the object handler.
 Although, it could also be obtained with something else like findSprite().

Possible values for aim are UP, DOWN, LEFT, RIGHT and HERE, These values cannot 
be combined.

<div class=code>
local bk, fw, ac, flags, player = getHitTestC( self,  UP  );
</div>

The results of this function can be a bit confusing. For starters, "flags" can 
be a combination of any of the following. 

<div class=code>
    FLAG_NONE		   
    FLAG_METAL		   
    FLAG_NOSOUND       
    FLAG_WATER	
    FLAG_DEATH	
    FLAG_HIT		    
    FLAG_TELEPORT       
</div>

bk is an array of classes.

fw is an array of classes and objId. There value are in pair starting at index 1.


ac is an array of classes and objId. There value are in pair starting at index 1.


<div class=code>
for i=1, #fw, 2 do
  local class = fw[i] ;
  local objId = fw[i + 1];
  -- do something else ....   
end

for i=1, #ac, 2 do
  local class = ac[i] ;
  local objId = ac[i + 1];
  -- do something else ....   
end
</div>

player is boolean that indicate whether or not the player is there.



<div class=fnFinal>int getHP() [cpp]</div>

  IN:  na

  OUT: [[ int ]] player hp


<div class=hdr3>paramOuts:</div>

   int             player hit's points count


<div class=hdr3>description:</div>

Get the player's Hit Point count.

example:

<div class=code>
setHP(500);
Debug:printf("hp:  %d", getHP());
</div>



<div class=fnFinal>mixed getImage(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: [[ int ]] imageSet
       [[ int ]] ImageNo

<div class=hdr3>description:</div>

Return the imageSet and imageNo for a given sprite

<div class=code>
local imageSet;
local imageNo;
imageSet, imageNo = getImage(selt);
</div>



<div class=fnFinal>mixed getImageSize(int imageSet, int imageNo) [cpp]</div>

  IN:  [[ int ]] imageSet
       [[ int ]] imageNo

  OUT: [[ int ]] length
       [[ int ]] height

<div class=hdr3>description:</div>

Returns the image length and height in pixels for an image designated by the 
imageSet  / imageNo pair.

<div class=code>
local s = getSprite(self);
local sx, sy = getImageSize(s.imageSet, s.imageNo);
if s.y + sy >= BUFFERHEI then
  s:setState(STATE_DEAD);
  s:hide();
end
</div>



<div class=fnFinal>int getLastKey() [cpp]</div>

  IN:  na

  OUT: [[ int ]] keyCode

<div class=hdr3>description:</div>

Get the last key pressed. Use this in keyUP and keyPressed events to know which 
key was pressed.

<div class=code>

-- this would be called inside the keyPressed 
-- or keyUp handler

local keyCode = getLastKey();
if keyCode == KEY_SPACE then
   setBkColor(rand(), rand(), rand());
else
   Debug:printf("last key: %d", keyCode);
end
</div>



<div class=fnFinal>Layer getLayer(string name) [lua]</div>

  IN:  [[ string ]] name

  OUT: [[ Layer ]] 

<div class=hdr3>description:</div>

Returns the layer object matching the name provided. Use this function for 
background or foreground layer. This will not work with the main layer.

<div class=code>
local layer = getLayer( "fw");
local element = layer:addElement(IMAGES_WHITEBALL_PNG, 0, 100, 100, true);
</div>



<div class=fnFinal>int getLayerC(String name) [cpp]</div>

  IN:  [[ String ]] name

  OUT: [[ int ]] layerId

<div class=hdr3>description:</div>

return the layerId matching name or -1 if not found.

<div class=code>
Debug:printf("layer fw is :%d", getLayerC ( "fw"));
</div>



<div class=fnFinal>int getLevelGoal() [cpp]</div>

  IN:  na

  OUT: [[ int ]] levelGoal

<div class=hdr3>description:</div>

The goal can be any of following values. (please note that they cannot be 
combined)

<div class=code>
        GOAL_ONLY               
        GOAL_UP                
        GOAL_DOWN         
        GOAL_LEFT            
        GOAL_RIGHT         
        GOAL_NO_COMPLETE        
</div>

GOAL_ONLY: when all goal marked objects are collected (removed)

GOAL_UP: when all goal marked objects are collected and player reaches the top 
of level (LODERUNNER)

GOAL_DOWN: when all goal marked objects are collected and player reaches the 
bottom of level.

GOAL_LEFT: when all goal marked objects are collected and player reaches the 
most left position.

GOAL_DOWN: when all goal marked objects are collected and player reaches the 
most right position .

GOAL_NO_COMPLETE : this requires that the level be declared completed via 
EndLevel function as to automatic completion is checked.

<div class=code>
Debug:printf("level goal: %d", getLevelGoal());
</div>



<div class=fnFinal>bool getLookUp() [cpp]</div>

  IN:  na

  OUT: [[ bool ]] 

<div class=hdr3>description:</div>

this function returns true if lookup is enabled. otherwise it returns false.



<div class=fnFinal>int getObjClass(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: [[ int ]] classId


<div class=hdr3>paramOuts:</div>

   int             class id of this object


<div class=hdr3>description:</div>

Return the class of a given object. The classId is one of the predefined 
constants CLASS_XXXXX.



<div class=fnFinal>string getObjName(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: [[ string ]] name


<div class=hdr3>paramOuts:</div>

   string          name of the object


<div class=hdr3>description:</div>

Returns a string containg the object name. (null terminated string, max 31 
characters)

<div class=code>
Debug:printf("player picked up a %s", getObjName(self));
</div>



<div class=fnFinal>int getObjType(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: [[ int ]] objType

<div class=hdr3>description:</div>

Get the object type for a given object ( e.g. instance ). 

these values can be corrolated with the OBJECT_XXXX constants defined by LGCK 
for your game.

example:

<div class=code>
debug("type: " .. getObjType( self ));
debug("name:" .. getObjName( self ));
</div>



<div class=fnFinal>Sprite getPlayer() [lua]</div>

  IN:  na

  OUT: [[ Sprite ]] 

<div class=hdr3>description:</div>

Get a Sprite object that contains the information about the player. Returns a 
wrapper with the desired data.

<div class=code>
local player = getPlayer();
Debug:printf("player id= %d; name: %s", player.id, player.name);
</div>



<div class=fnFinal>int getPlayerC() [cpp]</div>

  IN:  na

  OUT: [[ int ]] objId

<div class=hdr3>description:</div>

returns the objId of the player. 

<div class=code>
local id = getPlayerC();
Debug:printf("player_id: %x", id);
</div>



<div class=fnFinal>Proto getProto(int objType) [lua]</div>

  IN:  [[ int ]] objType

  OUT: [[ Proto ]] 

<div class=hdr3>description:</div>

Get the information about a given objType. Return a Proto object containing the 
data requested.



<div class=fnFinal>array getProtoC(int objType) [cpp]</div>

  IN:  [[ int ]] objType

  OUT: [[ array ]] proto

<div class=hdr3>description:</div>

Get the proto information for a given objType. Returns an array with the data 
requested.



<div class=fnFinal>int getScore() [cpp]</div>

  IN:  na

  OUT: [[ int ]] current score


<div class=hdr3>paramOuts:</div>

   int             the current score of the player


<div class=hdr3>description:</div>

Returns the player' score.

<div class=code>
debug( "score:" .. getScore());
</div>



<div class=fnUndef>mixed getScreenSize() [cpp]</div>

  IN:  na

  OUT: [[ int ]] len
       [[ int ]] hei

<div class=hdr3>description:</div>

Returns a tuple containing the screen size (opengl context).



<div class=fnFinal>int getSkill() [cpp]</div>

  IN:  na

  OUT: [[ int ]] skill

<div class=hdr3>description:</div>

Get the skill level for the current game. 

The value retuned is one of the following.

<div class=code>
SKILL_NORMAL	    
SKILL_NIGHTMARE	    
SKILL_HELL	
SKILL_INSANE	    
</div>

example
<div class=code>
if getSkill() == SKILL_NORMAL then
  debug("=>normal difficulty");
  setTickScale(1000 / 80);
  addToHP(50);
end
</div>



<div class=fnFinal>Sprite getSprite(int objId) [lua]</div>

  IN:  [[ int ]] objId

  OUT: [[ Sprite ]] 

<div class=hdr3>description:</div>

similar to getSpriteVars except that it will return the data inside as an object 
for easier management.

one thing to remember though is that modify individual fields of ``sprite`` will 
not alter the sprite. only your copy.

to make changes, you must call base methods such as s:setAim(). see example

<div class=code>
  local s = getSprite(self);

  debug("this is my detail:");
  debug("x = " .. s.x);
  debug("y = " .. s.y);

  local aim = s.aim;

  s:unMap();

  if s:canFall () then
    s:move( DOWN )  ;
  else
    if ticks % 5 == 0 then   

      if s:isPlayerThere(aim) then
	  s:attackPlayer();
      end

      if aim < LEFT or aim > RIGHT then
	aim = LEFT
      end

      if s:canMove(aim) then
	s:move(aim);
	if s:canFall() then
	  aim = XOR(aim, 1);
	  s:move(aim);
	end 
      else
	  aim = XOR( aim, 1);      
      end

      s:setAim ( aim );

    end 
  end

  s:map();
</div>



<div class=fnFinal>int getSpriteCount() [cpp]</div>

  IN:  na

  OUT: [[ int ]] spriteCount

<div class=hdr3>description:</div>

returns the number of sprites in the mainLayer.



<div class=fnFinal>mixed getSpriteVars(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: [[ int ]] x
       [[ int ]] y
       [[ int ]] aim
       [[ int ]] objectType
       [[ int ]] imageSetId
       [[ int ]] imageNo
       [[ int ]] triggerFlag
       [[ int ]] stateFlag
       [[ int ]] actionMask

<div class=hdr3>description:</div>

* triggerFlag bit mask
    01, 02, 04, 08, 10  TRIGGER_KEYS		= 0x1f
    20               	TRIGGER_GOAL		= 0x20
    40               	TRIGGER_FROZEN		= 0x40
    80               	TRIGGER_HIDDEN		= 0x80

  to get the triggerKey out of triggerFlag use `AND (triggerFlag, TRIGGER_KEYS)`.


  goal, frozen and hidden can be access using the TRIGGER_xxxx method above
  see common.lua for the definitions.

  this is stuff for advanced users

  * stateFlag
  
  use STATE_XXXX constants

<div class=code>
local x;
local y;
local aim;
x , y, aim = getSpriteVars( self );
</div>



<div class=fnFinal>int getTicks() [cpp]</div>

  IN:  na

  OUT: [[ int ]] ticks

<div class=hdr3>description:</div>

ticks are the internal unit for relative speed comparison within the engine.

the number of ticks per seconds is directly related to the tick scale.

the best way to deal with ticks is time splicing

example

<div class=code>
local ticks = getTicks();
if ticks % 5 == 0 then
  -- this will be executed 20% of the time
  -- or 1 in every 5 cycles
end
</div>



<div class=fnFinal>int getTickScale() [cpp]</div>

  IN:  na

  OUT: [[ int ]] tickScale

<div class=hdr3>description:</div>

The tickScale is the number of times per second that the engine main loop is 
executed. see setTickScale for details



<div class=fnFinal>int getTime() [cpp]</div>

  IN:  na

  OUT: [[ int ]] time elapsed

<div class=hdr3>description:</div>

Returns the time elapsed in miliseconds since the engine was started. Depening 
on the content this could be the level or the whole game.

1000 = 1 second in real time

<div class=code>
Debug:printf("%d", getTime() );
</div>



<div class=fnFinal>int getTriggerKey(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: [[ int ]] triggerKey




<div class=fnFinal>int getVersion() [cpp]</div>

  IN:  na

  OUT: [[ int ]] lgck_version

<div class=hdr3>description:</div>

This function returns the version of lgck currently powering up the game engine.

<div class=code>
Debug:printf("version: %8.8x", getVersion());
</div>



<div class=fnFinal>int getWrapFlag() [cpp]</div>

  IN:  na

  OUT: [[ int ]] wrapFlag

<div class=hdr3>description:</div>

Returns the wrap arround state for the current level.

Valid values are a combination of the following.

<div class=code>
        WRAP_UP                 
        WRAP_DOWN          
        WRAP_LEFT             
        WRAP_RIGHT          
</div>

<div class=code>
local wrapFlag = getWrapFlag();
Debug:printf("wrapFlag: %d", wrapFlag);
</div>

You can test for individual directions using the binary AND operator.

<div class=code>
AND (wrapFlag, WRAP_UP)
</div>



<div class=fnFinal>bool hasGravity() [cpp]</div>

  IN:  na

  OUT: [[ bool ]] gravity

<div class=hdr3>description:</div>

return true if gravity is enabled on this level.

<div class=code>
if (hasGravity()) then 
   debug("this level has gravity");
else
   debug("this level doesn't have gravity"); 
end
</div>



<div class=fnUntested>bool hasItem(int objType) [cpp]</div>

  IN:  [[ int ]] objType

  OUT: [[ bool ]] result

<div class=hdr3>description:</div>

Return true if the objType is part of the player's inventory.



<div class=fnFinal>void hideSprite(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: na

<div class=hdr3>description:</div>

Set the hidden flag on this sprite. This will cause the engine to not display 
this given sprite/object. All system based classes will also ignore this sprite 
until it becomes visible again.



<div class=fnFinal>bool isDead(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: [[ bool ]] 

<div class=hdr3>description:</div>

returns true if the sprite is dead.

<div class=code>
if isDead(self) then
   Debug:printf("This sprite is dead");
end
</div>



<div class=fnUntested>bool isHidden(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: [[ bool ]] 

<div class=hdr3>description:</div>

Return true if this object is hidden. Please note that this doesn't apply to 
system invisible objects which are not considered hidden in the strict sense of 
the word here.



<div class=fnUntested>bool isMonster(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: [[ bool ]] 

<div class=hdr3>description:</div>

returns true if the object is a monster.



<div class=fnFinal>bool isPlayerThere(int objId, int aim) [cpp]</div>

  IN:  [[ int ]] objId
       [[ int ]] aim

  OUT: [[ bool ]] 


<div class=hdr3>paramIns:</div>

   objId           
   aim             UP, DOWN, LEFT or RIGHT



<div class=hdr3>paramOuts:</div>

   bool            true if player is there, otherwise false





<div class=fnFinal>bool isVisible(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: [[ bool ]] 


<div class=hdr3>paramOuts:</div>

   bool            true if visible on screen, otherwise false





<div class=fnFinal>void killPlayer() [cpp]</div>

  IN:  na

  OUT: na




<div class=fnFinal>void killSprite(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: na

<div class=hdr3>description:</div>

Don't try this inside the sprite's own event handler!!!
Don't use this on a player object. Use killPlayer() or player:setState( STATE_
DEAD ) instead as this will not have the desired effect.



<div class=fnUntested>void land(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: na

<div class=hdr3>description:</div>

The land() method is called by the engine whenever a sprite has landed (
following a fall). The usefulness of this method is debatable at runtime. 
However, it is made available should be it prove useful in custom handlers/ai 
where this functionality might have a purpose. (e.g. if you are creating a 
custom monster whereas the engine will not handle these details for you)



<div class=fnFinal>bool layer_clear(int layerId) [cpp]</div>

  IN:  [[ int ]] layerId

  OUT: [[ bool ]] result

<div class=hdr3>description:</div>

Clear the layer designed by layer id. This function will return true if 
succesful.

<div class=code>
local id = getLayerC("fw");
if layer_clear( id ) then
  Debug:printf("layer was cleared");
end
</div>



<div class=fnFinal>mixed layer_getElement(int layerId, int elementId) [cpp]</div>

  IN:  [[ int ]] layerId
       [[ int ]] elementId

  OUT: [[ int ]] imageSet
       [[ int ]] ImageNo
       [[ int ]] x
       [[ int ]] y
       [[ bool ]] show




<div class=fnFinal>int layer_getSize(int layerId) [cpp]</div>

  IN:  [[ int ]] layerId

  OUT: [[ int ]] size

<div class=hdr3>description:</div>

This function returns the object/sprite count on the layer identified by layerId.
 You can get the layerId with getLayerC().

<div class=code>
local id = getLayerC ( "fw");
Debug:printf("layer size: %d", layer_getSize( id ));
</div>



<div class=fnFinal>void mapSprite(int objId, ...) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: na




<div class=fnFinal>void markSpriteAsGoal(int objId) [cpp]</div>

  IN:  [[ int objId ]] 

  OUT: na

<div class=hdr3>description:</div>

Set the sprite to be a goal for the level to be completed.



<div class=fnUntested>int MAX(int value1, int value2) [cpp]</div>

  IN:  [[ int ]] value1
       [[ int ]] value2

  OUT: [[ int ]] 

<div class=hdr3>description:</div>

return the largest of the two integers being passed to it.



<div class=fnUntested>int MIN(int value1, int value2) [cpp]</div>

  IN:  [[ int ]] value1
       [[ int ]] value2

  OUT: [[ int ]] 

<div class=hdr3>description:</div>

return the smallest  value of the two integers.



<div class=fnFinal>void moveSprite(int objId, int aim) [cpp]</div>

  IN:  [[ int ]] objId
       [[ int ]] aim

  OUT: na

<div class=hdr3>description:</div>

aim is one of the UP, DOWN, LEFT and RIGHT constants

you generally check to see of the object can move in a given direction using 
canMove()



<div class=fnFinal>void moveSprite(int objId, int tx, int ty) [cpp]</div>

  IN:  [[ int ]] objId
       [[ int ]] tx
       [[ int ]] ty

  OUT: na

<div class=hdr3>description:</div>

you generally check to see of the object can move in a given direction using 
canMove()

this second version also allows you to control the translation from current 
position. if you want defined where to position it then use moveSpriteTo().



<div class=fnFinal>void moveSpriteBy(int objId, int tx, int tx) [cpp]</div>

  IN:  [[ int ]] objId
       [[ int ]] tx
       [[ int ]] tx

  OUT: na

<div class=hdr3>description:</div>

you generally check to see of the object can move in a given direction using 
canMove()

this allows you to control the translation from current position. if you want 
defined where to position it then use moveSpriteTo().



<div class=fnFinal>void moveSpriteTo(int objId, int x, int y) [cpp]</div>

  IN:  [[ int ]] objId
       [[ int ]] x
       [[ int ]] y

  OUT: na

<div class=hdr3>description:</div>

note: prior to moving, animating, killing or deleting a sprite you should first
use unMapSprite(). if you wish to still use it you will also  need to use 
mapSprite after the transformation.

Please ensure that x and y coordonates are multiples of 8 and within the 
game world. You can do that with the bitwise operator AND (x, 0xfff8).



<div class=fnUndef>void nextTick() [n/a]</div>

  IN:  na

  OUT: na




<div class=fnUntested>bool openStream(string soundFile) [cpp]</div>

  IN:  [[ string ]] soundFile

  OUT: [[ bool ]] 


<div class=hdr3>paramIns:</div>

   soundFile       This can ogg, wav or another file format supported by SFML.


<div class=hdr3>description:</div>

Open a sound file for streaming. If the soundFile was opened succesfully, this 
function will return true. Your next step is to call playStream() to play the 
file. 

<div class=code>
openStream("level01.ogg");
</div>



<div class=fnFinal>int OR(int a, int b) [cpp]</div>

  IN:  [[ int ]] a
       [[ int ]] b

  OUT: [[ int ]] binary or (a , b)




<div class=fnFinal>void pause() [cpp]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

pause the game. equivalent to pressing F4



<div class=fnFinal>void playSound(string sound...) [cpp]</div>

  IN:  [[ string ]] sound

  OUT: na

<div class=hdr3>description:</div>

Loads a sound resource from the current lgckdb database and plays it. The name 
of the sound is case sensitive so please be sure to have exact same spelling.

This function can accept multiple inputs. 

<div class=code>
  playSound("OUCH");
  playSound("OUCH", "JUMP");
</div>



<div class=fnUntested>void playStream() [cpp]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

Play an opened stream. You must first use openStream() to ready the stream to be 
played.



<div class=fnFinal>int rand() [cpp]</div>

  IN:  na

  OUT: [[ int ]] 

<div class=hdr3>description:</div>

returns a random value.



<div class=fnUntested>void removeDisplayById(int displayId) [cpp]</div>

  IN:  [[ int ]] displayId

  OUT: na




<div class=fnUntested>void removeDisplayByName(string name) [lua]</div>

  IN:  [[ string ]] name

  OUT: na




<div class=fnUntested>void removeFromInventory(int objType) [cpp]</div>

  IN:  [[ int ]] objType

  OUT: na




<div class=fnUntested>void resetInventory() [cpp]</div>

  IN:  na

  OUT: na




<div class=fnFinal>void setAim(int objId, int aim) [cpp]</div>

  IN:  [[ int ]] objId
       [[ int ]] aim

  OUT: na




<div class=fnFinal>void setBkColor(int red, int green, int blue) [lua]</div>

  IN:  [[ int ]] red
       [[ int ]] green
       [[ int ]] blue

  OUT: na

<div class=hdr3>description:</div>

Set the background color for the current level from the red, green and blue 
components of the provided as three integer values (max 255, 255, 255 is pure 
white). This is just an alias for the now depreciated setBkColorC function.

<div class=code>
setBkColor(128, 40, 64);
</div>



<div class=fnFinal>void setBkColorC(int red, int green, int blue) [cpp]</div>

  IN:  [[ int ]] red
       [[ int ]] green
       [[ int ]] blue

  OUT: na

<div class=hdr3>description:</div>

Set the background color for a given level.

<div class=code>
-- set the background color at random
setBkColorC(rand() % 256, rand() % 256, rand() % 256);
</div>



<div class=fnFinal>void setBorderColor(int red, int green, int blue) [cpp]</div>

  IN:  [[ int ]] red
       [[ int ]] green
       [[ int ]] blue

  OUT: na

<div class=hdr3>description:</div>

set border color.

<div class=code>
setBorderColor(rand(),rand(),rand());
</div>



<div class=fnFinal>void setEndLevel() [cpp]</div>

  IN:  na

  OUT: na




<div class=fnFinal>int setHP(int hitPoints) [cpp]</div>

  IN:  [[ int ]] hitPoints

  OUT: [[ int ]] the player's new hp count

<div class=hdr3>description:</div>

Set the player's Hit Point count;

example:

<div class=code>
setHP(500);
Debug:printf("hp:  %d", getHP());
</div>



<div class=fnFinal>void setImage(int objId, int imageSet, int imageNo) [cpp]</div>

  IN:  [[ int ]] objId
       [[ int ]] imageSet
       [[ int ]] imageNo

  OUT: na

<div class=hdr3>description:</div>

Change the image for a given sprite.

The example below shows best practice. Alternative methods include tryAnimation()
.

<div class=code>
local imageSet;
local imageNo;
imageSet, imageNo = getImage(selt);
setImage(self, imageSet, XOR(imageNo, 1));
</div>



<div class=fnUntested>void setKey(int keyCode, bool set) [cpp]</div>

  IN:  [[ int ]] keyCode
       [[ bool ]] set

  OUT: na

<div class=hdr3>description:</div>

If set is true this key is considered pressed otherwise it is considered not 
pressed.



<div class=fnFinal>void setLevelGoal(int goal) [cpp]</div>

  IN:  [[ int ]] goal

  OUT: na

<div class=hdr3>description:</div>

The goal can be any of following values. (please note that they cannot be 
combined)

<div class=code>
GOAL_ONLY               
GOAL_UP                
GOAL_DOWN         
GOAL_LEFT            
GOAL_RIGHT         
GOAL_NO_COMPLETE        
</div>

GOAL_ONLY: when all goal marked objects are collected

GOAL_UP: when all goal marked objects are collected and player reaches the top 
of level (LODERUNNER)

GOAL_DOWN: when all goal marked objects are collected and player reaches the 
bottom of level.

GOAL_LEFT: when all goal marked objects are collected and player reaches the 
most left position.

GOAL_DOWN: when all goal marked objects are collected and player reaches the 
most right position .

GOAL_NO_COMPLETE : this requires that the level be declared completed via 
EndLevel function as to automatic completion is checked.

<div class=code>
-- prevent this level from being completed automatically
setLevelGoal(GOAL_NO_COMPLETE);
</div>



<div class=fnFinal>void setLookup(bool lookup) [cpp]</div>

  IN:  [[ bool ]] lookup

  OUT: na

<div class=hdr3>description:</div>

Enables or disables lookup.



<div class=fnUndef>void setNextSecond() [n/a]</div>

  IN:  na

  OUT: na




<div class=fnFinal>void setSpeed(int speed) [cpp]</div>

  IN:  [[ int ]] speed

  OUT: na

<div class=hdr3>description:</div>

Set the game speed. The default value is 90. The maximum value is 200.

The speed is calculated as follow. 1000 / speed = number of cycles per second.

Each cycle is a tick. This is the base unit for everything in the game itself.

Also setTickScale()



<div class=fnFinal>int setState(int objId, int stateFlag, bool flip) [cpp]</div>

  IN:  [[ int ]] objId
       [[ int ]] stateFlag
       [[ bool ]] flip

  OUT: [[ int ]] stateFlag

<div class=hdr3>description:</div>

Change the state flags for a given sprite.

if flip is true the bits are set on otherwise they are cleared.

State flag is a combination of the following:

<div class=code>
    STATE_FALL		
    STATE_DEAD	
    STATE_HIT		    
    STATE_JUMP	
    STATE_BEGINNING    
    STATE_FIRING       
    STATE_LOOKUP       
</div>

returns the newly modified stateFlag.



<div class=fnFinal>void setTickScale(int tickScale) [cpp]</div>

  IN:  [[ int ]] tickScale

  OUT: na

<div class=hdr3>description:</div>

Change the level tick scale. This makes the game go faster or slower.

Tick scale is calculate : 1000 / TickRate

TickRate is the number of times per second that the main loop is executed.

See example:

<div class=code>
-- in this example the tick rate is 95
-- which is very fast !!!

if SKILL == SKILL_INSANE then
  debug("=>insane difficulty");
  setTickScale(1000 / 95);
  addToHP(-20);
end
</div>



<div class=fnFinal>void setTriggerKey(int objId, int key) [cpp]</div>

  IN:  [[ int ]] objId
       [[ int ]] key

  OUT: na


<div class=hdr3>paramIns:</div>

   objId           
   key             valid values are between 1 and 31


<div class=hdr3>description:</div>

changes the trigger key of a given obj. if set to zero, this will clear the 
trigger key
entirely. values will be binary AND with 0x1f to ensure they are within limit. 
Valid trigger keys are between 1 and 31.



<div class=fnFinal>void setWrapFlag(int wrapFlag) [cpp]</div>

  IN:  [[ int ]] wrapFlag

  OUT: na

<div class=hdr3>description:</div>

This function modifies the behavior defined for the level. 

Wrap allows object to move from one edge of the map to the other.

A popular example of this is the classic PACMAN.

wrapFlag can be a combination of the following value.

<div class=code>
WRAP_UP             
WRAP_DOWN      
WRAP_LEFT         
WRAP_RIGHT      
</div>

<div class=code>
-- allow wrapping only at the the top of the screen
setWrapFlag( WRAP_UP );
-- check the flag to see that change was made
local wrapFlag = getWrapFlag();
Debug:printf("A wrapFlag: %d", wrapFlag);
</div>



<div class=fnFinal>void showConsole(bool show) [lua]</div>

  IN:  [[ bool ]] show

  OUT: na

<div class=hdr3>description:</div>

examples

<div class=code>
showConsole ( true )
showConsole ( false )
</div>



<div class=fnFinal>void showSprite(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: na

<div class=hdr3>description:</div>

show the current sprite. This reverses the hideSprite() function. If the sprite 
is already visible this will not have any effect on it.



<div class=fnUntested>void spawn(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: na

<div class=hdr3>description:</div>

Spawn is called upon during the creation of a new sprite to initialize the 
member variables. It's usefulness at runtime is debatable. However, it is 
available should there be a need for it.



<div class=fnFinal>string sprintf(string format, ...) [lua]</div>

  IN:  [[ string ]] format

  OUT: [[ string ]] 

<div class=hdr3>description:</div>

This function formats a text string. Works exactly like it's C counterpart. 

<div class=code>
local s = sprintf("My name is %s", "Frank");
-- print the result to the debug console
Debug:printf(s);

local s = sprintf("1 + 1 = %d", 2);
-- print the result to the debug console
Debug:printf(s);
</div>



<div class=fnUndef>void sprite_addItem(int objId, int protoId, int count) [n/a]</div>

  IN:  [[ int ]] objId
       [[ int ]] protoId
       [[ int ]] count

  OUT: na




<div class=fnUntested>int sprite_childCount(int spriteId) [cpp]</div>

  IN:  [[ int ]] spriteId

  OUT: [[ int ]] childCount

<div class=hdr3>description:</div>

Count the number of children sprites. There are typically bullets.



<div class=fnFinal>int sprite_frameCount(int objid) [cpp]</div>

  IN:  [[ int ]] objid

  OUT: [[ int ]] number_of_frames

<div class=hdr3>description:</div>

Get the frame count for a given sprite. This is based on the current frameset 
associated with this sprite.



<div class=fnUndef>int sprite_get(int objId, string name) [cpp]</div>

  IN:  [[ int ]] objId
       [[ string ]] name

  OUT: [[ int ]] value




<div class=fnUntested>int sprite_getHeight(int sprite_id) [cpp]</div>

  IN:  [[ int ]] sprite_id

  OUT: [[ int ]] height

<div class=hdr3>description:</div>

Get the sprite heigth.



<div class=fnUndef>int sprite_getHP(int objId) [n/a]</div>

  IN:  [[ int ]] objId

  OUT: [[ int ]] hp

<div class=hdr3>description:</div>

Get the sprite HP



<div class=fnUntested>string sprite_getString(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: [[ string ]] 

<div class=hdr3>description:</div>

Get the custom hint/description associated with a given sprite.



<div class=fnUntested>int sprite_getWidth(int sprite_id) [cpp]</div>

  IN:  [[ int sprite_id ]] 

  OUT: [[ int ]] width

<div class=hdr3>description:</div>

Get the sprite width (pixels).



<div class=fnUndef>bool sprite_hasItem(int objId, int protoId) [n/a]</div>

  IN:  [[ int ]] objId
       [[ int ]] protoId

  OUT: [[ bool ]] hasItem




<div class=fnUntested>bool sprite_isActive(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: [[ bool ]] active

<div class=hdr3>description:</div>

Return the active state of a given sprite. (bool: true, false)



<div class=fnUndef>bool sprite_isFrozen(int objId) [n/a]</div>

  IN:  [[ int ]] objId

  OUT: [[ bool ]] frozen

<div class=hdr3>description:</div>

returns true if the sprite is frozen.



<div class=fnUndef>bool sprite_isGoal(int objId) [n/a]</div>

  IN:  [[ int ]] objId

  OUT: [[ bool ]] goal

<div class=hdr3>description:</div>

returns true if the sprite is marked as a goal.



<div class=fnUntested>bool sprite_isPlayer(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: [[ bool ]] 

<div class=hdr3>description:</div>

Tests if the sprite is a player object. Returns true if sprite is of player 
class.



<div class=fnUndef>void sprite_removeItem(int objId, int protoId) [n/a]</div>

  IN:  [[ int ]] objId
       [[ int ]] protoId

  OUT: na




<div class=fnUndef>void sprite_resetInventory(int objId) [n/a]</div>

  IN:  [[ int ]] objId

  OUT: na




<div class=fnUndef>void sprite_set(int objId, string name, int value) [cpp]</div>

  IN:  [[ int ]] objId
       [[ string ]] name
       [[ int ]] value

  OUT: na




<div class=fnUntested>void sprite_setHP(int hp) [cpp]</div>

  IN:  [[ int ]] hp

  OUT: na

<div class=hdr3>description:</div>

Set the sprite hit points



<div class=fnUntested>void sprite_setOwner(int objId, int ownerid) [cpp]</div>

  IN:  [[ int ]] objId
       [[ int ]] ownerid

  OUT: na

<div class=hdr3>description:</div>

Set the owner of this sprite



<div class=fnFinal>void ss_animate() [cpp]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

internal. Used by the engine to animate all sprites.



<div class=fnFinal>void ss_autoCenter() [cpp]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

internal



<div class=fnUndef>void ss_clear(int red, int green, int blue) [cpp]</div>

  IN:  [[ int ]] red
       [[ int ]] green
       [[ int ]] blue

  OUT: na

<div class=hdr3>description:</div>

Clear the screen with a given color.



<div class=fnFinal>void ss_clearKeys() [cpp]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

Internal. Clear keyboard map.



<div class=fnFinal>void ss_doManage() [cpp]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

internal. Used by the engine to manage all sprite interactions in the game 
context.



<div class=fnFinal>void ss_drawText(int x, int y, string text, int fontid, int fontSize, int rgba, 
[ int shadowOffset ], [ int shadowColor ]) [cpp]</div>

  IN:  [[ int ]] x
       [[ int ]] y
       [[ string ]] text
       [[ int ]] fontid
       [[ int ]] fontSize
       [[ int ]] rgba
       [[ int ]] shadowOffset*
       [[ int ]] shadowColor*

  OUT: na

<div class=hdr3>description:</div>

Draw text on the screen at x,y. Memory arrangement of the rgba color is 
0xAABBGGRR. This function must be executed within the onDraw function otherwise 
it will have no effect.

<div class=code>
ss_drawText(100, 50, "This is a test", 0, 20, 0xa0ee20cc, 2, 0xffffffff);
</div>



<div class=fnFinal>int ss_getNextTick() [cpp]</div>

  IN:  na

  OUT: [[ int ]] 

<div class=hdr3>description:</div>

Returns time in milliseconds of the next engine tick.



<div class=fnFinal>bool ss_getPause() [cpp]</div>

  IN:  na

  OUT: [[ bool ]] 

<div class=hdr3>description:</div>

This function returns true if the game is paused,



<div class=fnFinal>void ss_manageAuto() [cpp]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

internal



<div class=fnFinal>void ss_manageKeyEvents() [cpp]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

internal



<div class=fnFinal>void ss_managePlayer() [cpp]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

internal.



<div class=fnFinal>void ss_manageTasks() [cpp]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

internal



<div class=fnFinal>void ss_paint(int x1, int y1, int x2, int y2, unsigned int rgba, bool fill) [
cpp]</div>

  IN:  [[ int ]] x1
       [[ int ]] y1
       [[ int ]] x2
       [[ int ]] y2
       [[ unsigned int ]] rgba
       [[ bool ]] fill

  OUT: na

<div class=hdr3>description:</div>

Draw a rectangle of a given color. If fill is set the rectangle is full 
otherwise it will be hollow. Memory arrangement of the rgba color is 0xAABBGGRR.
 This function must be executed within the onDraw function otherwise it will 
have no effect.

<div class=code>
ss_paint(0,0,40,40, 0xaa00aa90, TRUE);
</div>



<div class=fnUndef>void ss_paintImage(int x, int y, int frameSet, int frameNo) [cpp]</div>

  IN:  [[ int ]] x
       [[ int ]] y
       [[ int ]] frameSet
       [[ int ]] frameNo

  OUT: na

<div class=hdr3>description:</div>

internal. Draw an image on screen at x,y.



<div class=fnFinal>void ss_setNextTick(int time) [cpp]</div>

  IN:  [[ int ]] time

  OUT: na

<div class=hdr3>description:</div>

Set the time in milliseconds for the next engine tick.



<div class=fnFinal>void stopAnimation(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: na

<div class=hdr3>description:</div>

Stop the current animation sequence. This is also breaks repeating animations.

<div class=code>
stopAnimation(self);
</div>



<div class=fnFinal>void stopStream() [cpp]</div>

  IN:  na

  OUT: na

<div class=hdr3>description:</div>

Stop a playing sound/music stream

<div class=code>
stopStream();
</div>



<div class=fnFinal>bool testFlags(int objId, int mask) [cpp]</div>

  IN:  [[ int ]] objId
       [[ int ]] mask

  OUT: [[ bool ]] true if bitwise matched

<div class=hdr3>description:</div>

note: currently this function only works with the player object
      flags are outlined as const FLAG_xxxxx

you must supply both args or the function will return false
and spit out a warning on the debug console
  
<div class=code>
  local sound = "";
  if not testFlags(self,  FLAG_NOSOUND)  then
    if  testFlags(self , FLAG_METAL)   then
	  sound = "METAL";
    else
      if ticks % 12 == 0 then
	  sound = "WALK2";
      else
	  sound = "WALK";
      end
    end
    playSound( sound );
  end
</div>

The mask can be a combination of any of the following. Although, generally 
speaking you want to include only one.

<div class=code>
    FLAG_NONE		   
    FLAG_METAL		   
    FLAG_NOSOUND       
    FLAG_WATER	
    FLAG_DEATH	
    FLAG_HIT		    
    FLAG_TELEPORT       
</div>



<div class=fnFinal>bool testJoyState(int mask) [cpp]</div>

  IN:  [[ int ]] mask

  OUT: [[ bool ]] true if bitwise matched, otherwise false


<div class=hdr3>paramIns:</div>

   mask            bitwise mask


<div class=hdr3>description:</div>

note: currently this function only works with the player object

  states are outlined as const JOY_xxxxx

<div class=code>
  if (ticks % 5 == 0) and testJoyState( JOY_FIRE ) then
    local x;
    local y;
    local aim;
  
    x , y, aim = getSpriteVars( self );

    if testJoyState( JOY_LEFT ) then 
      aim = LEFT;
      x = x - 8;
      y = y + 8;
    elseif testJoyState( JOY_RIGHT ) then
      aim = RIGHT;
      x = x + 32;
      y = y + 8;
    elseif testJoyState( JOY_UP ) then
      aim = UP;
      x = x + 8;
      y = y - 8;
    elseif testJoyState( JOY_DOWN ) then
      aim = DOWN;
      x = x + 8;
      y = y + 32;
    end 

    local bullet = addSprite (
      x, 
      y, 
      aim,					-- UP, DOWN, LEFT, RIGHT
    OBJECT_BULLET_LITTLE_STAR__PLY_		-- put the object type 
    );

    playSound("pow.ogg");
  end
</div>



<div class=fnUntested>bool testKey(int keyCode) [cpp]</div>

  IN:  [[ int ]] keyCode

  OUT: [[ bool ]] 

<div class=hdr3>description:</div>

The keyCode can be any of the following values. This fucntion returns true if 
the key is pressed. Other values may have unpredictable results.

<div class=code>
   KEY_A                = 0x61;
    KEY_B                = 0x62;
    KEY_C                = 0x63;
    KEY_D                = 0x64;
    KEY_E                = 0x65;
    KEY_F                = 0x66;
    KEY_G                = 0x67;
    KEY_H                = 0x68;
    KEY_I                = 0x69;
    KEY_J                = 0x6a;
    KEY_K                = 0x6b;
    KEY_L                = 0x6c;
    KEY_M                = 0x6d;
    KEY_N                = 0x6e;
    KEY_O                = 0x6f;
    KEY_P                = 0x70;
    KEY_Q                = 0x71;
    KEY_R                = 0x72;
    KEY_S                = 0x73;
    KEY_T                = 0x74;
    KEY_U                = 0x75;
    KEY_V                = 0x76;
    KEY_W                = 0x77;
    KEY_X                = 0x78;
    KEY_Y                = 0x79;
    KEY_Z                = 0x7a;
    KEY_0                = 0x30;
    KEY_1                = 0x31;
    KEY_2                = 0x32;
    KEY_3                = 0x33;
    KEY_4                = 0x34;
    KEY_5                = 0x35;
    KEY_6                = 0x36;
    KEY_7                = 0x37;
    KEY_8                = 0x38;
    KEY_9                = 0x39;
    KEY_F1               = 0x131;
    KEY_F2               = 0x132;
    KEY_F3               = 0x133;
    KEY_F4               = 0x134;
    KEY_F5               = 0x135;
    KEY_F6               = 0x136;
    KEY_F7               = 0x137;
    KEY_F8               = 0x138;
    KEY_F9               = 0x139;
    KEY_ESCAPE           = 0x100;
    KEY_CTRL             = 0x101;
    KEY_SHIFT            = 0x102;
    KEY_ALT              = 0x103;
    KEY_MENU             = 0x109;
    KEY_LBRACKET         = 0x10a;
    KEY_RBRACKET         = 0x10b;
    KEY_SEMICOLON        = 0x10c;
    KEY_COMA             = 0x10d;
    KEY_PERIOD           = 0x10e;
    KEY_QUOTE            = 0x10f;
    KEY_SLASH            = 0x110;
    KEY_BACKSLASH        = 0x111;
    KEY_TILDE            = 0x112;
    KEY_EQUAL            = 0x113;
    KEY_MINUS            = 0x114;
    KEY_SPACE            = 0x115;
    KEY_RETURN           = 0x116;
    KEY_BACKSPACE        = 0x117;
    KEY_TAB              = 0x118;
    KEY_PAGEUP           = 0x119;
    KEY_PAGEDOWN         = 0x11a;
    KEY_END              = 0x11b;
    KEY_HOME             = 0x11c;
    KEY_INSERT           = 0x11d;
    KEY_DELETE           = 0x11e;
    KEY_PLUS             = 0x11f;
    KEY_MINUS            = 0x120;
    KEY_MULTIPLY         = 0x121;
    KEY_DIVIDE           = 0x122;
    KEY_LEFT             = 0x123;
    KEY_RIGHT            = 0x124;
    KEY_UP               = 0x125;
    KEY_DOWN             = 0x126;
    KEY_PAUSE            = 0x140;    
</div>



<div class=fnFinal>int ticks() [lua]</div>

  IN:  na

  OUT: [[ int ]] ticks

<div class=hdr3>description:</div>

This is just an alias. see getTicks() for details.



<div class=fnFinal>void triggerHitState(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: na

<div class=hdr3>description:</div>

Trigger the hit state for a given object. This is usually called when the object 
is "hurt". 

ObjId is the sprite id. 

No return value.



<div class=fnFinal>void triggerPlayerHitState() [cpp]</div>

  IN:  na

  OUT: na




<div class=fnFinal>bool tryAnimation(int objId, int animSeq) [cpp]</div>

  IN:  [[ int ]] objId
       [[ int ]] animSeq

  OUT: [[ bool ]] 

<div class=hdr3>description:</div>

This plays a designated animation sequence for a given objectId. If you are 
using this function inside an event handle, the objectId is often the `self` 
variable which points to the object being handled.

The animation sequence is one of the following values. In order to use this 
animation, the target object must have corresponding images attached to it.

<div class=code>
AS_DEFAULT 
AS_IDLE       
AS_CUSTOM1    
AS_CUSTOM2    
AS_STAND        
AS_STAND_UP
AS_STAND_DOWN  
AS_STAND_LEFT  
AS_STAND_RIGHT  
AS_MOVE       
AS_MOVE_UP     
AS_MOVE_DOWN    
AS_MOVE_LEFT    
AS_MOVE_RIGHT  
AS_JUMP         
AS_JUMP_UP 
AS_JUMP_DOWN  
AS_JUMP_LEFT   
AS_JUMP_RIGHT  
AS_HURT        
AS_HURT_UP      
AS_HURT_DOWN 
AS_HURT_LEFT    
AS_HURT_RIGHT 
AS_ATTACK      
AS_ATTACK_UP    
AS_ATTACK_DOWN  
AS_ATTACK_LEFT 
AS_ATTACK_RIGHT 
AS_RUN          
AS_RUN_UP     
AS_RUN_DOWN    
AS_RUN_LEFT     
AS_RUN_RIGHT   
AS_DEAD        
AS_DEAD_UP      
AS_DEAD_DOWN    
AS_DEAD_LEFT   
AS_DEAD_RIGHT  
</div>

This function returns true if succesful or false if the animSeq value is out of 
bound or the object has no animation sequence defined which match the animSeq 
value.

<div class=code>
if tryAnimation(self,  AS_DEAD_UP) then
   debug("animation worked!!! :D");
end
</div>



<div class=fnFinal>bool tryPath(int objId, int pathDir, [ int aim ]) [cpp]</div>

  IN:  [[ int ]] objId
       [[ int ]] pathDir
       [[ int ]] aim*

  OUT: [[ bool ]] 

<div class=hdr3>description:</div>

Have the designated object try a path. The pathDir can be any of the following 
constants.

<div class=code>
        PS_DEFAULT     
        PS_IDLE        
        PS_CUSTOM1      
        PS_CUSTOM2    
        PS_ATTACK      
        PS_ATTACK_UP 
        PS_ATTACK_DOWN 
        PS_ATTACK_LEFT 
        PS_ATTACK_RIGHT
        PS_JUMP        
        PS_JUMP_UP
        PS_JUMP_DOWN    
        PS_JUMP_LEFT  
        PS_JUMP_RIGHT  
        PS_JUMP_UP_LEFT 
        PS_JUMP_UP_RIGHT
        PS_JUMP_DN_LEFT
        PS_JUMP_DN_RIGHT
        PS_MOVE       
        PS_MOVE_UP
        PS_MOVE_DOWN  
        PS_MOVE_LEFT  
        PS_MOVE_RIGHT  
        PS_MOVE_UP_LEFT
        PS_MOVE_UP_RIGHT
        PS_MOVE_DN_LEFT 
        PS_MOVE_DN_RIGHT
</div>

Aim can be either UP, DOWN, LEFT or RIGHT.  If aim is not provided, INVALID is 
assumed.

Return true if the path defined. This function is similar to tryAnimation().  It 
only works with the player at the moment.

<div class=code>
local id = getPlayerC();
Debug:printf("player_id: %x", id);
tryPath(id, PS_JUMP_LEFT);
</div>



<div class=fnFinal>void unFreezeSprite(int objId) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: na

<div class=hdr3>description:</div>

Reverse the effect of freezeSprite. reactivative it.

another way of doing this is through the Sprite interface.

<div class=code>
activateSprite(self);

-- is equivalent to

local sprite;
sprite = getSprite(self);
sprite:activate();
</div>



<div class=fnFinal>void unMapSprite(int objId...) [cpp]</div>

  IN:  [[ int ]] objId

  OUT: na

<div class=hdr3>description:</div>

unMapSprite is required before making any changes to a sprite's position, 
visibility or attributes.  not doing so will result in very nasty and hard to 
track bugs.



<div class=fnUndef>void updateHP() [cpp]</div>

  IN:  na

  OUT: na




<div class=fnUndef>void updateJoyState() [n/a]</div>

  IN:  na

  OUT: na




<div class=fnUndef>void warpTo(string uuid) [cpp]</div>

  IN:  [[ string ]] uuid

  OUT: na




<div class=fnFinal>int XOR(int a, int b) [cpp]</div>

  IN:  [[ int ]] a
       [[ int ]] b

  OUT: [[ int ]] binary eXclusive OR (a , b)

<div class=hdr3>description:</div>

<div class=code>

  XOR (1, 7)  -- expected resut:  6

  -- explanation
  1 = 1000
  7 = 1110
    XOR
  6 = 0110

  XOR (2, 3)  -- expected resut: 1

  -- explanation
  2 = 0100
  3 = 1100
    XOR
  1 = 1000

  etc.

</div>
  </pre>
 </body>
</html>
